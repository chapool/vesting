# HZToken åˆçº¦æŠ€æœ¯å®ç°

## æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†æè¿° HZ Token ç”Ÿæ€ç³»ç»Ÿä¸­å„ä¸ªæ™ºèƒ½åˆçº¦çš„æŠ€æœ¯å®ç°ï¼ŒåŒ…æ‹¬è®¾è®¡ç†å¿µã€æ ¸å¿ƒç®—æ³•ã€æ¥å£è®¾è®¡ã€å®‰å…¨æœºåˆ¶å’Œä½¿ç”¨ç¤ºä¾‹ã€‚

**æ–‡æ¡£ç‰ˆæœ¬**: v2.1  
**æœ€åæ›´æ–°**: 2025å¹´8æœˆ4æ—¥

> ğŸ“‹ **ç‰ˆæœ¬æ›´æ–°è¯´æ˜**: æœ¬ç‰ˆæœ¬åŒ…å«äº†é‡å¤§å®‰å…¨å¢å¼ºã€åŠ¨æ€äº¤æ˜“ç¨ç³»ç»Ÿã€åˆ†å±‚IDç®¡ç†ç­‰åŠŸèƒ½æ›´æ–°ã€‚è¯¦ç»†æ›´æ–°æ—¥å¿—è¯·å‚é˜… [æ›´æ–°æ—¥å¿—](./6.Updates.md)ã€‚

---

## ç›®å½•

1. [HZ Token åˆçº¦](#1-hz-token-åˆçº¦)
2. [Vesting åˆçº¦](#2-vesting-åˆçº¦)
3. [MiningPool åˆçº¦](#3-miningpool-åˆçº¦)
4. [Constants åˆçº¦](#4-constants-åˆçº¦)
5. [æ¥å£å®šä¹‰](#5-æ¥å£å®šä¹‰)
6. [äº‹ä»¶ç³»ç»Ÿ](#6-äº‹ä»¶ç³»ç»Ÿ)
7. [éƒ¨ç½²é…ç½®](#7-éƒ¨ç½²é…ç½®)
8. [å¸¸è§é—®é¢˜](#8-å¸¸è§é—®é¢˜)

---

## 1. HZ Token åˆçº¦

### 1.1 åˆçº¦æ¦‚è¿°

HZToken æ˜¯ HZ ç”Ÿæ€ç³»ç»Ÿçš„æ ¸å¿ƒä»£å¸åˆçº¦ï¼ŒåŸºäº ERC-20 æ ‡å‡†å®ç°ï¼Œå…·å¤‡é“¸é€ ã€é”€æ¯ã€æš‚åœã€é»‘åå•å’Œäº¤æ˜“ç¨ç­‰æ‰©å±•åŠŸèƒ½ã€‚

### 1.2 è®¾è®¡ç†å¿µ 

HZToken ç‰ˆæœ¬ 2.1 é‡‡ç”¨**å›ºå®šæ€»é‡ + æ™ºèƒ½ç¨æ”¶ + å—æ§é‡Šæ”¾**çš„å…ˆè¿›è®¾è®¡æ¨¡å¼ï¼š
- **æ€»é‡å›ºå®š**: æœç»é€šèƒ€é£é™©ï¼Œä¿æŠ¤æŒæœ‰è€…åˆ©ç›Š
- **æ™ºèƒ½ç¨æ”¶**: åˆ›æ–°çš„åŠ¨æ€äº¤æ˜“ç¨ç³»ç»Ÿï¼Œé€‚åº”ä¸åŒå¸‚åœºæ¡ä»¶
- **ç®€åŒ–ç®¡ç†**: ä»åŸºäºè§’è‰²ç®¡ç†æ”¹ä¸ºåŸºäºæ‰€æœ‰è€…ç®¡ç†ï¼Œæé«˜å®‰å…¨æ€§
- **åˆ†å±‚é‡Šæ”¾**: é€šè¿‡ Vesting æœºåˆ¶ç¡®ä¿æœ‰åºé‡Šæ”¾
- **å¤šé‡ç”¨é€”**: æ”¯æŒæŒ–çŸ¿å¥–åŠ±ã€ç”Ÿæ€æ¿€åŠ±ã€å›¢é˜Ÿæ¿€åŠ±ç­‰å¤šåœºæ™¯

### 1.3 æ ¸å¿ƒæ•°æ®ç»“æ„ 

```solidity
contract HZToken is 
    Initializable, 
    ERC20Upgradeable, 
    ERC20BurnableUpgradeable, 
    ERC20PausableUpgradeable, 
    OwnableUpgradeable,
    ReentrancyGuardUpgradeable,
    Constants,
    IHZToken
{
    // é»‘åå•ç®¡ç†
    mapping(address => bool) private _blacklisted;
    
    // ğŸ¯ åŠ¨æ€äº¤æ˜“ç¨é…ç½®
    struct TaxConfig {
        uint256 buyTax;          // ä¹°å…¥ç¨ (åŸºç‚¹)
        uint256 sellTax;         // å–å‡ºç¨ (åŸºç‚¹)
        uint256 transferTax;     // è½¬è´¦ç¨ (åŸºç‚¹)
        uint256 liquidityTax;    // æµåŠ¨æ€§ç¨ (åŸºç‚¹)
        bool dynamicTaxEnabled;  // åŠ¨æ€ç¨ç‡å¼€å…³
        uint256 maxDynamicRate;  // åŠ¨æ€è°ƒæ•´æœ€å¤§å€æ•° (åŸºç‚¹ï¼Œ100=1å€)
    }
    
    TaxConfig public taxConfig;
    address public taxRecipient;
    bool public taxEnabled;
    
    // AMMå’Œäº¤æ˜“æ‰€åœ°å€ç®¡ç†
    mapping(address => bool) public isAMM;           // AMMæ± æ ‡è¯†
    mapping(address => bool) public isTaxExempt;     // å…ç¨åœ°å€
    mapping(address => bool) public isLiquidityPool; // æµåŠ¨æ€§æ± æ ‡è¯†
    
    // ğŸ§  åŠ¨æ€ç¨ç‡è°ƒæ•´å‚æ•°
    struct DynamicTaxParams {
        uint256 volumeThreshold;     // äº¤æ˜“é‡é˜ˆå€¼
        uint256 timeWindow;          // æ—¶é—´çª—å£
        uint256 priceImpactFactor;   // ä»·æ ¼å½±å“å› å­
        uint256 volatilityFactor;    // æ³¢åŠ¨æ€§å› å­
    }
    
    DynamicTaxParams public dynamicParams;
    
    // ğŸ“Š äº¤æ˜“ç»Ÿè®¡æ•°æ®
    struct TradingStats {
        uint256 totalVolume24h;      // 24å°æ—¶äº¤æ˜“é‡
        uint256 lastStatsUpdate;     // ä¸Šæ¬¡ç»Ÿè®¡æ›´æ–°æ—¶é—´
        uint256 largeTransactionCount; // å¤§é¢äº¤æ˜“è®¡æ•°
        uint256 averageTransactionSize; // å¹³å‡äº¤æ˜“å¤§å°
    }
    
    TradingStats public tradingStats;
    
    // ğŸ“ˆ äº¤æ˜“å†å²è®°å½•ï¼ˆç”¨äºåŠ¨æ€è°ƒæ•´ï¼‰
    struct TransactionRecord {
        uint256 amount;
        uint256 timestamp;
        bool isBuy;
        bool isSell;
    }
    
    TransactionRecord[] private recentTransactions;
    uint256 private constant MAX_RECENT_TRANSACTIONS = 100;
    
    // ç‰ˆæœ¬æ§åˆ¶ï¼ˆç”¨äºå¯å‡çº§åˆçº¦ï¼‰
    uint256[50] private __gap;
}
```

**ğŸ”„ é‡è¦å˜æ›´è¯´æ˜**:

1. **ç®¡ç†æ¨¡å¼å˜æ›´**: ä» `AccessControlUpgradeable` æ”¹ä¸º `OwnableUpgradeable`
   - ç®€åŒ–æƒé™ç®¡ç†ï¼Œæé«˜å®‰å…¨æ€§
   - ç§»é™¤å¤æ‚çš„è§’è‰²ç³»ç»Ÿï¼Œé‡‡ç”¨æ‰€æœ‰è€…ç®¡ç†æ¨¡å¼

2. **åŠ¨æ€ç¨æ”¶ç³»ç»Ÿ**: æ–°å¢å®Œæ•´çš„åŠ¨æ€ç¨æ”¶æ¶æ„
   - æ”¯æŒä¹°å…¥/å–å‡º/è½¬è´¦/æµåŠ¨æ€§å››ç§ç¨ç‡ç±»å‹
   - åŸºäºäº¤æ˜“é‡ã€é‡‘é¢ã€ç±»å‹çš„æ™ºèƒ½è°ƒæ•´
   - å®æ—¶ç»Ÿè®¡å’Œå†å²æ•°æ®åˆ†æ

3. **åœ°å€ç®¡ç†ä¼˜åŒ–**: æ–°å¢æ‰¹é‡ç®¡ç†åŠŸèƒ½
   - AMMæ± åœ°å€ç®¡ç†
   - å…ç¨åœ°å€æ‰¹é‡è®¾ç½®
   - æµåŠ¨æ€§æ± è¯†åˆ«æœºåˆ¶

### 1.4 åŠ¨æ€äº¤æ˜“ç¨ç³»ç»Ÿ â­

#### 1.4.1 æ ¸å¿ƒç¨æ”¶é…ç½®

æ–°ç‰ˆæœ¬å®ç°äº†ä¸šç•Œé¢†å…ˆçš„åŠ¨æ€äº¤æ˜“ç¨ç³»ç»Ÿï¼Œæ”¯æŒæ™ºèƒ½ç¨ç‡è°ƒæ•´ï¼š

```solidity
struct TaxConfig {
    uint256 buyTax;          // ä¹°å…¥ç¨ (åŸºç‚¹)
    uint256 sellTax;         // å–å‡ºç¨ (åŸºç‚¹)
    uint256 transferTax;     // è½¬è´¦ç¨ (åŸºç‚¹)
    uint256 liquidityTax;    // æµåŠ¨æ€§ç¨ (åŸºç‚¹)
    bool dynamicTaxEnabled;  // åŠ¨æ€ç¨ç‡å¼€å…³
    uint256 maxDynamicRate;  // åŠ¨æ€è°ƒæ•´æœ€å¤§å€æ•°
}

struct DynamicTaxParams {
    uint256 volumeThreshold;     // äº¤æ˜“é‡é˜ˆå€¼
    uint256 timeWindow;          // æ—¶é—´çª—å£
    uint256 priceImpactFactor;   // ä»·æ ¼å½±å“å› å­
    uint256 volatilityFactor;    // æ³¢åŠ¨æ€§å› å­
}
```

#### 1.4.2 æ™ºèƒ½ç¨ç‡è®¡ç®—

åŠ¨æ€ç¨æ”¶åŸºäºå¤šä¸ªå› ç´ å®æ—¶è°ƒæ•´ï¼š

```solidity
function _calculateDynamicTax(address from, address to, uint256 amount) internal view returns (uint256) {
    uint256 baseTaxRate = _getBaseTaxRate(from, to);
    
    if (!taxConfig.dynamicTaxEnabled) {
        return (amount * baseTaxRate) / 10000;
    }
    
    // è®¡ç®—åŠ¨æ€è°ƒæ•´å› å­
    uint256 dynamicMultiplier = _calculateDynamicMultiplier(from, to, amount);
    uint256 adjustedTaxRate = (baseTaxRate * dynamicMultiplier) / 100;
    
    // é™åˆ¶æœ€å¤§ç¨ç‡
    uint256 maxTaxRate = (baseTaxRate * taxConfig.maxDynamicRate) / 100;
    if (adjustedTaxRate > maxTaxRate) {
        adjustedTaxRate = maxTaxRate;
    }
    
    return (amount * adjustedTaxRate) / 10000;
}
```

#### 1.4.3 ç¨æ”¶é¢„è§ˆåŠŸèƒ½

ç”¨æˆ·å¯ä»¥åœ¨æ‰§è¡Œäº¤æ˜“å‰é¢„è§ˆç¨æ”¶ï¼š

```solidity
function previewTax(address from, address to, uint256 amount) 
    external view returns (
        uint256 taxAmount,
        uint256 transferAmount,
        string memory taxType,
        uint256 baseTaxRate,
        uint256 dynamicMultiplier
    );
```

### 1.5 æ ¸å¿ƒåŠŸèƒ½å®ç°

#### 1.5.1 åˆå§‹åŒ–å’ŒåŸºç¡€åŠŸèƒ½

**åˆçº¦åˆå§‹åŒ–** - æ›¿ä»£ä¼ ç»Ÿæ„é€ å‡½æ•°

```solidity
function initialize(string memory name_, string memory symbol_, address vestingContract) public initializer {
    __ERC20_init(name_, symbol_);
    __ERC20Burnable_init();
    __ERC20Pausable_init();
    __Ownable_init();  // ğŸ”„ ä½¿ç”¨ Ownable æ›¿ä»£ AccessControl
    __ReentrancyGuard_init();

    // åˆå§‹åŒ–åŠ¨æ€ç¨æ”¶é…ç½®
    taxConfig = TaxConfig({
        buyTax: DEFAULT_TRANSACTION_TAX_RATE,      // é»˜è®¤1%ä¹°å…¥ç¨
        sellTax: DEFAULT_TRANSACTION_TAX_RATE,     // é»˜è®¤1%å–å‡ºç¨
        transferTax: DEFAULT_TRANSACTION_TAX_RATE / 2, // é»˜è®¤0.5%è½¬è´¦ç¨
        liquidityTax: DEFAULT_TRANSACTION_TAX_RATE / 4, // é»˜è®¤0.25%æµåŠ¨æ€§ç¨
        dynamicTaxEnabled: false,                   // é»˜è®¤å…³é—­åŠ¨æ€ç¨ç‡
        maxDynamicRate: 300                        // æœ€å¤§3å€åŠ¨æ€è°ƒæ•´
    });
    
    // åˆå§‹åŒ–åŠ¨æ€ç¨ç‡å‚æ•°
    dynamicParams = DynamicTaxParams({
        volumeThreshold: TOTAL_SUPPLY / 1000,      // 0.1%æ€»ä¾›åº”é‡ä½œä¸ºé˜ˆå€¼
        timeWindow: 1 hours,                       // 1å°æ—¶æ—¶é—´çª—å£
        priceImpactFactor: 150,                    // 1.5å€ä»·æ ¼å½±å“å› å­
        volatilityFactor: 200                      // 2å€æ³¢åŠ¨æ€§å› å­
    });
    
    // åˆå§‹åŒ–äº¤æ˜“ç»Ÿè®¡
    tradingStats.lastStatsUpdate = block.timestamp;
    
    // åˆå§‹é“¸é€ ï¼šå°†æ‰€æœ‰ä»£å¸é“¸é€ åˆ° Vesting åˆçº¦
    require(vestingContract != address(0), "HZ: vesting contract cannot be zero");
    _mint(vestingContract, TOTAL_SUPPLY);
}
```

#### 1.5.2 é“¸é€ åŠŸèƒ½ (Mint)
- **æƒé™**: ä»… MINTER_ROLE è§’è‰²
- **ç”¨é€”**: åˆå§‹ä»£å¸åˆ†å‘
- **é™åˆ¶**: æ€»é‡ä¸è¶…è¿‡é¢„è®¾ä¸Šé™

```solidity
// ğŸ”„ æƒé™ç®¡ç†å˜æ›´ï¼šä»è§’è‰²ç®¡ç†æ”¹ä¸ºæ‰€æœ‰è€…ç®¡ç†
function mint(address to, uint256 amount) external onlyOwner {
    require(totalSupply() + amount <= TOTAL_SUPPLY, "HZ: exceeds max supply");
    _mint(to, amount);
}
```

#### 1.4.2 é”€æ¯åŠŸèƒ½ (Burn)
- **æƒé™**: ä»£å¸æŒæœ‰è€…è‡ªä¸»é”€æ¯
- **ç”¨é€”**: å‡å°‘æµé€šä¾›åº”é‡
- **æœºåˆ¶**: ä¸å¯é€†é”€æ¯

```solidity
function burn(uint256 amount) external {
    _burn(msg.sender, amount);
}

function burnFrom(address account, uint256 amount) external {
    uint256 currentAllowance = allowance(account, msg.sender);
    require(currentAllowance >= amount, "ERC20: burn amount exceeds allowance");
    _approve(account, msg.sender, currentAllowance - amount);
    _burn(account, amount);
}
```

#### 1.5.3 æ™ºèƒ½è½¬è´¦å’ŒåŠ¨æ€ç¨æ”¶å®ç° â­

**æ ¸å¿ƒè½¬è´¦é€»è¾‘** - é›†æˆåŠ¨æ€ç¨æ”¶å’Œå®‰å…¨æ£€æŸ¥

```solidity
function _transfer(address from, address to, uint256 amount) internal override {
    require(!_blacklisted[from], "HZ: sender blacklisted");
    require(!_blacklisted[to], "HZ: recipient blacklisted");
    
    // ğŸ”„ æ–°å¢ï¼šæ›´æ–°äº¤æ˜“ç»Ÿè®¡
    _updateTradingStats(from, to, amount);
    
    // ğŸ¯ åŠ¨æ€ç¨æ”¶è®¡ç®—å’Œæ‰§è¡Œ
    if (taxEnabled && taxRecipient != address(0) && !isTaxExempt[from] && !isTaxExempt[to]) {
        uint256 taxAmount = _calculateDynamicTax(from, to, amount);
        
        if (taxAmount > 0) {
            uint256 transferAmount = amount - taxAmount;
            
            super._transfer(from, taxRecipient, taxAmount);
            super._transfer(from, to, transferAmount);
            
            emit TaxDeducted(from, to, taxAmount, _getTaxType(from, to));
        } else {
            super._transfer(from, to, amount);
        }
    } else {
        super._transfer(from, to, amount);
    }
}

// ğŸ§  åŠ¨æ€ç¨æ”¶è®¡ç®—æ ¸å¿ƒç®—æ³•
function _calculateDynamicTax(address from, address to, uint256 amount) internal view returns (uint256) {
    // è·å–åŸºç¡€ç¨ç‡
    uint256 baseTaxRate = _getBaseTaxRate(from, to);
    
    if (baseTaxRate == 0) return 0;
    
    // å¦‚æœåŠ¨æ€ç¨ç‡å…³é—­ï¼Œè¿”å›åŸºç¡€ç¨ç‡
    if (!taxConfig.dynamicTaxEnabled) {
        return (amount * baseTaxRate) / 10000;
    }
    
    // è®¡ç®—åŠ¨æ€è°ƒæ•´å› å­
    uint256 dynamicMultiplier = _calculateDynamicMultiplier(from, to, amount);
    
    // åº”ç”¨åŠ¨æ€è°ƒæ•´
    uint256 adjustedTaxRate = (baseTaxRate * dynamicMultiplier) / 100;
    
    // ç¡®ä¿ä¸è¶…è¿‡æœ€å¤§åŠ¨æ€ç¨ç‡
    uint256 maxTaxRate = (baseTaxRate * taxConfig.maxDynamicRate) / 100;
    if (adjustedTaxRate > maxTaxRate) {
        adjustedTaxRate = maxTaxRate;
    }
    
    return (amount * adjustedTaxRate) / 10000;
}

// ğŸ¯ åŸºç¡€ç¨ç‡ç¡®å®š
function _getBaseTaxRate(address from, address to) internal view returns (uint256) {
    // æµåŠ¨æ€§ç›¸å…³äº¤æ˜“
    if (isLiquidityPool[from] || isLiquidityPool[to]) {
        return taxConfig.liquidityTax;
    }
    
    // ä¹°å…¥äº¤æ˜“ (ä»AMMæ± è½¬å‡º)
    if (isAMM[from] && !isAMM[to]) {
        return taxConfig.buyTax;
    }
    
    // å–å‡ºäº¤æ˜“ (è½¬å…¥AMMæ± )
    if (!isAMM[from] && isAMM[to]) {
        return taxConfig.sellTax;
    }
    
    // æ™®é€šè½¬è´¦
    return taxConfig.transferTax;
}
```

#### 1.5.4 é»‘åå•ç®¡ç†
- **æƒé™**: åˆçº¦æ‰€æœ‰è€… (onlyOwner)
- **ç”¨é€”**: é™åˆ¶æ¶æ„åœ°å€çš„äº¤æ˜“è¡Œä¸º
- **æœºåˆ¶**: é»‘åå•åœ°å€æ— æ³•è¿›è¡Œä»»ä½•ä»£å¸æ“ä½œ

```solidity
// ğŸ”„ æƒé™ç®¡ç†å˜æ›´ï¼šä½¿ç”¨ onlyOwner æ›¿ä»£è§’è‰²ç®¡ç†
function addToBlacklist(address account) external onlyOwner {
    require(!_blacklisted[account], "HZ: already blacklisted");
    _blacklisted[account] = true;
    emit BlacklistAdded(account);
}

function removeFromBlacklist(address account) external onlyOwner {
    require(_blacklisted[account], "HZ: not blacklisted");
    _blacklisted[account] = false;
    emit BlacklistRemoved(account);
}
```

#### 1.5.5 åŠ¨æ€äº¤æ˜“ç¨ç®¡ç† â­

**è®¾ç½®ç¨æ”¶é…ç½®** - æ”¯æŒå¤šå±‚çº§ç¨ç‡è®¾ç½®

```solidity
function setTaxConfig(
    uint256 buyTax,
    uint256 sellTax,
    uint256 transferTax,
    uint256 liquidityTax,
    bool dynamicEnabled,
    uint256 maxDynamicRate
) external onlyOwner {
    require(buyTax <= MAX_TRANSACTION_TAX_RATE, "HZ: buy tax too high");
    require(sellTax <= MAX_TRANSACTION_TAX_RATE, "HZ: sell tax too high");
    require(transferTax <= MAX_TRANSACTION_TAX_RATE, "HZ: transfer tax too high");
    require(liquidityTax <= MAX_TRANSACTION_TAX_RATE, "HZ: liquidity tax too high");
    require(maxDynamicRate <= 500, "HZ: max dynamic rate too high"); // æœ€å¤§5å€
    
    taxConfig.buyTax = buyTax;
    taxConfig.sellTax = sellTax;
    taxConfig.transferTax = transferTax;
    taxConfig.liquidityTax = liquidityTax;
    taxConfig.dynamicTaxEnabled = dynamicEnabled;
    taxConfig.maxDynamicRate = maxDynamicRate;
    
    emit TaxConfigUpdated(buyTax, sellTax, transferTax, liquidityTax, dynamicEnabled);
}
```

**æ‰¹é‡åœ°å€ç®¡ç†** - æé«˜Gasæ•ˆç‡

```solidity
// æ‰¹é‡è®¾ç½®AMMæ± åœ°å€
function batchSetAMM(address[] calldata pools, bool[] calldata flags) external onlyOwner {
    require(pools.length == flags.length, "HZ: arrays length mismatch");
    
    for (uint256 i = 0; i < pools.length; i++) {
        require(pools[i] != address(0), "HZ: invalid pool address");
        isAMM[pools[i]] = flags[i];
        emit AMMUpdated(pools[i], flags[i]);
    }
}

// æ‰¹é‡è®¾ç½®å…ç¨åœ°å€
function batchSetTaxExempt(address[] calldata accounts, bool[] calldata flags) external onlyOwner {
    require(accounts.length == flags.length, "HZ: arrays length mismatch");
    
    for (uint256 i = 0; i < accounts.length; i++) {
        require(accounts[i] != address(0), "HZ: invalid account address");
        isTaxExempt[accounts[i]] = flags[i];
        emit TaxExemptUpdated(accounts[i], flags[i]);
    }
}
```

### 1.6 å®‰å…¨æœºåˆ¶

#### 1.6.1 æƒé™æ§åˆ¶çŸ©é˜µ (ç‰ˆæœ¬ 2.1 æ›´æ–°)

**ğŸ”„ ç®¡ç†æ¨¡å¼å˜æ›´**: ä»å¤æ‚çš„è§’è‰²ç®¡ç†æ”¹ä¸ºç®€åŒ–çš„æ‰€æœ‰è€…ç®¡ç†

| åŠŸèƒ½ | Owner | User | è¯´æ˜ |
|------|-------|------|------|
| mint | âœ“ | âœ— | ä»…æ‰€æœ‰è€…å¯é“¸é€  |
| pause/unpause | âœ“ | âœ— | ä»…æ‰€æœ‰è€…å¯æš‚åœ |
| é»‘åå•ç®¡ç† | âœ“ | âœ— | ä»…æ‰€æœ‰è€…å¯ç®¡ç†é»‘åå• |
| ç¨æ”¶é…ç½® | âœ“ | âœ— | ä»…æ‰€æœ‰è€…å¯è®¾ç½®ç¨ç‡ |
| AMMæ± ç®¡ç† | âœ“ | âœ— | ä»…æ‰€æœ‰è€…å¯è®¾ç½®AMMæ±  |
| å…ç¨åœ°å€ç®¡ç† | âœ“ | âœ— | ä»…æ‰€æœ‰è€…å¯è®¾ç½®å…ç¨åœ°å€ |
| transfer | âœ“ | âœ“ | æ‰€æœ‰ç”¨æˆ·å¯è½¬è´¦ï¼ˆå—ç¨æ”¶å’Œé»‘åå•é™åˆ¶ï¼‰ |
| burn | âœ“ | âœ“ | æ‰€æœ‰ç”¨æˆ·å¯é”€æ¯è‡ªå·±çš„ä»£å¸ |
| ç¨æ”¶é¢„è§ˆ | âœ“ | âœ“ | æ‰€æœ‰ç”¨æˆ·å¯é¢„è§ˆç¨æ”¶ |

**ä¼˜åŠ¿**:
- âœ… **ç®€åŒ–ç®¡ç†**: å‡å°‘æƒé™å¤æ‚æ€§ï¼Œé™ä½å‡ºé”™é£é™©
- âœ… **æé«˜å®‰å…¨**: å•ä¸€æ§åˆ¶ç‚¹ï¼Œæ›´æ˜“äºä¿æŠ¤
- âœ… **é™ä½æˆæœ¬**: å‡å°‘è§’è‰²ç®¡ç†çš„Gasæ¶ˆè€—
- âœ… **æ˜“äºå®¡è®¡**: æƒé™ç»“æ„æ¸…æ™°æ˜äº†

#### 1.6.2 å¢å¼ºçš„å®‰å…¨ç‰¹æ€§å®ç°

```solidity
// ğŸ›¡ï¸ é‡å…¥æ”»å‡»é˜²æŠ¤ (ä½¿ç”¨OpenZeppelin ReentrancyGuard)
contract HZToken is ReentrancyGuardUpgradeable {
    function _transfer(address from, address to, uint256 amount) internal override {
        // å†…ç½®é‡å…¥ä¿æŠ¤
        // é»‘åå•æ£€æŸ¥
        require(!_blacklisted[from], "HZ: sender blacklisted");
        require(!_blacklisted[to], "HZ: recipient blacklisted");
        
        // æ›´æ–°äº¤æ˜“ç»Ÿè®¡
        _updateTradingStats(from, to, amount);
        
        // åŠ¨æ€ç¨æ”¶è®¡ç®—å’Œæ‰§è¡Œ
        if (taxEnabled && taxRecipient != address(0) && !isTaxExempt[from] && !isTaxExempt[to]) {
            uint256 taxAmount = _calculateDynamicTax(from, to, amount);
            
            if (taxAmount > 0) {
                uint256 transferAmount = amount - taxAmount;
                
                super._transfer(from, taxRecipient, taxAmount);
                super._transfer(from, to, transferAmount);
                
                emit TaxDeducted(from, to, taxAmount, _getTaxType(from, to));
            } else {
                super._transfer(from, to, amount);
            }
        } else {
            super._transfer(from, to, amount);
        }
    }
}

// ğŸ”’ å‚æ•°éªŒè¯å’Œå®‰å…¨æ£€æŸ¥
modifier validTaxConfig(uint256 buyTax, uint256 sellTax, uint256 transferTax, uint256 liquidityTax) {
    require(buyTax <= MAX_TRANSACTION_TAX_RATE, "HZ: buy tax exceeds maximum");
    require(sellTax <= MAX_TRANSACTION_TAX_RATE, "HZ: sell tax exceeds maximum");
    require(transferTax <= MAX_TRANSACTION_TAX_RATE, "HZ: transfer tax exceeds maximum");
    require(liquidityTax <= MAX_TRANSACTION_TAX_RATE, "HZ: liquidity tax exceeds maximum");
    _;
}

// ğŸ“Š æ™ºèƒ½ç»Ÿè®¡æ›´æ–°
function _updateTradingStats(address from, address to, uint256 amount) internal {
    uint256 currentTime = block.timestamp;
    
    // è‡ªåŠ¨é‡ç½®24å°æ—¶ç»Ÿè®¡
    if (currentTime > tradingStats.lastStatsUpdate + 24 hours) {
        tradingStats.totalVolume24h = 0;
        tradingStats.largeTransactionCount = 0;
        tradingStats.lastStatsUpdate = currentTime;
    }
    
    tradingStats.totalVolume24h += amount;
    
    // è®°å½•å¤§é¢äº¤æ˜“
    if (amount > dynamicParams.volumeThreshold * 5) {
        tradingStats.largeTransactionCount++;
    }
    
    // æ›´æ–°å¹³å‡äº¤æ˜“å¤§å°
    tradingStats.averageTransactionSize = tradingStats.totalVolume24h / (tradingStats.largeTransactionCount + 1);
    
    // è®°å½•æœ€è¿‘äº¤æ˜“ç”¨äºåŠ¨æ€è°ƒæ•´
    _recordRecentTransaction(from, to, amount);
}
```

---

## 2. Vesting åˆçº¦

### 2.1 åˆçº¦æ¦‚è¿°

Vesting åˆçº¦æ˜¯ HZ Token ç”Ÿæ€ç³»ç»Ÿä¸­çš„æ ¸å¿ƒåˆ†é…åˆçº¦ï¼Œè´Ÿè´£ç®¡ç†æ‰€æœ‰ä»£å¸çš„æ—¶é—´é”å®šå’Œé‡Šæ”¾æœºåˆ¶ã€‚æ”¯æŒå¤šç§é‡Šæ”¾ç­–ç•¥ï¼ŒåŒ…æ‹¬çº¿æ€§é‡Šæ”¾ã€åˆ†æœŸé‡Šæ”¾å’Œ Cliff Periodï¼ˆæ‚¬å´–æœŸï¼‰ã€‚

### 2.2 æ ¸å¿ƒæ¦‚å¿µ

#### 2.2.1 ä»€ä¹ˆæ˜¯ Vestingï¼Ÿ
Vesting æ˜¯æŒ‡ä»£å¸åœ¨ä¸€æ®µæ—¶é—´å†…é€æ¸é‡Šæ”¾ç»™å—ç›Šäººçš„è¿‡ç¨‹ï¼Œå…·æœ‰é‡è¦æ„ä¹‰ï¼š
- **é•¿æœŸæ¿€åŠ±**: é¼“åŠ±å‚ä¸è€…é•¿æœŸå‚ä¸é¡¹ç›®å‘å±•
- **ä»·æ ¼ç¨³å®š**: é¿å…å¤§é‡ä»£å¸åŒæ—¶è¿›å…¥å¸‚åœºé€ æˆä»·æ ¼æ³¢åŠ¨
- **é£é™©æ§åˆ¶**: é™ä½æ—©æœŸæŠ•èµ„è€…æˆ–å›¢é˜Ÿæˆå‘˜å¿«é€ŸæŠ›å”®çš„é£é™©
- **åˆ©ç›Šä¸€è‡´**: ä½¿å„æ–¹åˆ©ç›Šä¸é¡¹ç›®é•¿æœŸå‘å±•ä¿æŒä¸€è‡´

#### 2.2.2 é‡Šæ”¾ç­–ç•¥ç±»å‹

1. **æ—¶é—´çº¿æ€§é‡Šæ”¾**: ä»£å¸æŒ‰å›ºå®šæ—¶é—´é—´éš”è¿ç»­é‡Šæ”¾
2. **åˆ†æœŸé‡Šæ”¾**: ä»£å¸æŒ‰é¢„å®šèŠ‚ç‚¹æ‰¹é‡é‡Šæ”¾
3. **Cliff + çº¿æ€§ç»„åˆ**: ç»“åˆæ‚¬å´–æœŸå’Œçº¿æ€§é‡Šæ”¾çš„æ··åˆç­–ç•¥

### 2.3 æ ¸å¿ƒæ•°æ®ç»“æ„

```solidity
struct VestingSchedule {
    bool initialized;           // æ˜¯å¦å·²åˆå§‹åŒ–
    address beneficiary;        // å—ç›Šäººåœ°å€
    uint256 cliff;             // æ‚¬å´–æœŸæ—¶é•¿ï¼ˆç§’ï¼‰
    uint256 start;             // å¼€å§‹æ—¶é—´æˆ³
    uint256 duration;          // æ€»é‡Šæ”¾å‘¨æœŸï¼ˆç§’ï¼‰
    uint256 slicePeriodSeconds; // é‡Šæ”¾é—´éš”ï¼ˆç§’ï¼‰
    bool revocable;            // æ˜¯å¦å¯æ’¤é”€
    uint256 amountTotal;       // æ€»ä»£å¸æ•°é‡
    uint256 released;          // å·²é‡Šæ”¾æ•°é‡
    bool revoked;              // æ˜¯å¦å·²æ’¤é”€
    AllocationCategory category; // åˆ†é…ç±»å‹æ ‡è¯†
}

// åˆ†é…ç±»å‹æšä¸¾
enum AllocationCategory {
    MINING,        // æŒ–çŸ¿å¥–åŠ±
    ECOSYSTEM,     // è¿è¥ä¸ç”Ÿæ€å‘å±•
    TEAM,          // å›¢é˜Ÿå’Œé¡¾é—®
    CORNERSTONE    // åŸºçŸ³è½®æŠ•èµ„
}

// é‡Šæ”¾ç±»å‹æšä¸¾
enum VestingType {
    LINEAR,        // çº¿æ€§é‡Šæ”¾
    MILESTONE,     // åˆ†æœŸé‡Šæ”¾
    CLIFF_LINEAR   // Cliff + çº¿æ€§
}

contract Vesting is Initializable, OwnableUpgradeable, ReentrancyGuardUpgradeable {
    // ERC20 ä»£å¸åˆçº¦
    IERC20 private _token;
    
    // Vesting è®¡åˆ’æ˜ å°„
    mapping(bytes32 => VestingSchedule) private _vestingSchedules;
    
    // å—ç›Šäººçš„è®¡åˆ’æ•°é‡
    mapping(address => uint256) private _holdersVestingCount;
    
    // ç‰ˆæœ¬æ§åˆ¶ï¼ˆç”¨äºå¯å‡çº§åˆçº¦ï¼‰
    uint256[50] private __gap;
    
    // è®¡åˆ’IDæ•°ç»„
    bytes32[] private _vestingSchedulesIds;
    
    // ç»Ÿè®¡æ•°æ®
    uint256 private _vestingSchedulesTotalAmount;
    uint256 private _vestingSchedulesReleasedAmount;
}
```

### 2.4 æ ¸å¿ƒç®—æ³•

#### 2.4.1 å¯é‡Šæ”¾é‡‘é¢è®¡ç®—

çº¿æ€§é‡Šæ”¾è®¡ç®—æ˜¯ Vesting åˆçº¦çš„æ ¸å¿ƒç®—æ³•ï¼š

```solidity
function _computeReleasableAmount(VestingSchedule memory vestingSchedule) 
    private view returns (uint256) {
    
    uint256 currentTime = getCurrentTime();
    
    // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾å¼€å§‹æ—¶é—´ + cliff
    if (currentTime < vestingSchedule.start + vestingSchedule.cliff) {
        return 0;
    }
    
    // æ£€æŸ¥æ˜¯å¦è¶…è¿‡ç»“æŸæ—¶é—´
    if (currentTime >= vestingSchedule.start + vestingSchedule.duration) {
        return vestingSchedule.amountTotal - vestingSchedule.released;
    }
    
    // è®¡ç®—å·²ç»è¿‡çš„æ—¶é—´æ®µæ•°é‡
    uint256 timeFromStart = currentTime - vestingSchedule.start;
    uint256 secondsPerSlice = vestingSchedule.slicePeriodSeconds;
    uint256 vestedSlicePeriods = timeFromStart / secondsPerSlice;
    uint256 vestedSeconds = vestedSlicePeriods * secondsPerSlice;
    
    // è®¡ç®—åº”è¯¥é‡Šæ”¾çš„æ€»é‡
    uint256 vestedAmount = (vestingSchedule.amountTotal * vestedSeconds) 
                          / vestingSchedule.duration;
    
    return vestedAmount - vestingSchedule.released;
}
```

#### 2.4.2 åˆ›å»ºé‡Šæ”¾è®¡åˆ’

åˆ›å»º Vesting è®¡åˆ’çš„å®Œæ•´å®ç°ï¼ŒåŒ…å«æ‰€æœ‰éªŒè¯é€»è¾‘ï¼š

```solidity
function createVestingSchedule(
    address beneficiary,
    uint256 start,
    uint256 cliff,
    uint256 duration,
    uint256 slicePeriodSeconds,
    bool revocable,
    uint256 amount,
    AllocationCategory category
) external onlyOwner {
    require(beneficiary != address(0), "Beneficiary cannot be zero address");
    require(duration > 0, "Duration must be > 0");
    require(amount > 0, "Amount must be > 0");
    require(duration >= cliff, "Duration < cliff");
    require(slicePeriodSeconds >= 1, "SlicePeriodSeconds must be >= 1");
    
    bytes32 vestingScheduleId = computeVestingScheduleIdForAddressAndIndex(
        beneficiary, 
        _holdersVestingCount[beneficiary]
    );
    
    _vestingSchedules[vestingScheduleId] = VestingSchedule({
        initialized: true,
        beneficiary: beneficiary,
        cliff: cliff,
        start: start,
        duration: duration,
        slicePeriodSeconds: slicePeriodSeconds,
        revocable: revocable,
        amountTotal: amount,
        released: 0,
        revoked: false,
        category: category
    });
    
    _vestingSchedulesTotalAmount += amount;
    _vestingSchedulesIds.push(vestingScheduleId);
    _holdersVestingCount[beneficiary]++;
    
    emit VestingScheduleCreated(vestingScheduleId, beneficiary, amount);
}
```

#### 2.4.3 ä»£ç†é‡Šæ”¾åŠŸèƒ½

ä»£ç†é‡Šæ”¾åŠŸèƒ½å…è®¸åˆçº¦æ‰€æœ‰è€…ç›´æ¥å¸®åŠ©ç”¨æˆ·æå–å·²é‡Šæ”¾çš„ä»£å¸ï¼Œæ— éœ€ç”¨æˆ·æˆæƒï¼š

```solidity
/**
 * @dev Owner ä»£ä¸ºé‡Šæ”¾ç”¨æˆ·çš„å¯ç”¨ä»£å¸
 * @param vestingScheduleId è®¡åˆ’ID
 * @param amount é‡Šæ”¾æ•°é‡
 * @notice Owner å¯ä»¥ç›´æ¥ä¸ºç”¨æˆ·é‡Šæ”¾å·²è§£é”çš„ä»£å¸ï¼Œæ— éœ€ç”¨æˆ·æˆæƒ
 */
function releaseForBeneficiary(bytes32 vestingScheduleId, uint256 amount) 
    external onlyOwner nonReentrant {
    
    VestingSchedule storage vestingSchedule = _vestingSchedules[vestingScheduleId];
    require(vestingSchedule.initialized, "Vesting: schedule not found");
    require(!vestingSchedule.revoked, "Vesting: schedule revoked");
    
    uint256 releasableAmount = _computeReleasableAmount(vestingSchedule);
    require(amount <= releasableAmount, "Vesting: amount exceeds releasable");
    
    vestingSchedule.released += amount;
    _vestingSchedulesReleasedAmount += amount;
    
    _token.safeTransfer(vestingSchedule.beneficiary, amount);
    
    emit TokensReleasedByOwner(vestingScheduleId, vestingSchedule.beneficiary, amount);
}

/**
 * @dev æ‰¹é‡ä»£ç†é‡Šæ”¾åŠŸèƒ½
 * @param vestingScheduleIds è®¡åˆ’IDæ•°ç»„
 * @param amounts å¯¹åº”çš„é‡Šæ”¾æ•°é‡æ•°ç»„
 */
function batchReleaseForBeneficiaries(
    bytes32[] calldata vestingScheduleIds, 
    uint256[] calldata amounts
) external onlyOwner nonReentrant {
    require(vestingScheduleIds.length == amounts.length, "Vesting: arrays length mismatch");
    
    for (uint256 i = 0; i < vestingScheduleIds.length; i++) {
        if (amounts[i] > 0) {
            releaseForBeneficiary(vestingScheduleIds[i], amounts[i]);
        }
    }
}
```

**æ— æˆæƒä»£ç†é‡Šæ”¾çš„ä¼˜åŠ¿**:
- **ç®€åŒ–æµç¨‹**: å»é™¤äº†ç”¨æˆ·æˆæƒçš„å¤æ‚æµç¨‹ï¼Œæé«˜æ“ä½œæ•ˆç‡
- **æ›´å¥½çš„ç”¨æˆ·ä½“éªŒ**: ç”¨æˆ·æ— éœ€é¢å¤–æ“ä½œï¼Œç”± Owner ç»Ÿä¸€ç®¡ç†é‡Šæ”¾
- **æ‰¹é‡å¤„ç†**: æ”¯æŒæ‰¹é‡é‡Šæ”¾ï¼Œå¤§å¹…èŠ‚çœ Gas è´¹ç”¨
- **ç´§æ€¥æƒ…å†µå¤„ç†**: å½“ç”¨æˆ·æ— æ³•æ“ä½œæ—¶ï¼ŒOwner å¯ä»¥åŠæ—¶å¸®åŠ©é‡Šæ”¾
- **ç»Ÿä¸€ç®¡ç†**: Owner å¯ä»¥ç»Ÿä¸€ç®¡ç†æ‰€æœ‰çš„ä»£å¸é‡Šæ”¾ï¼Œæ›´åŠ é«˜æ•ˆ

### 2.6 ç‰ˆæœ¬ 2.1 äº‹ä»¶ç³»ç»Ÿæ›´æ–°

**æ–°å¢äº‹ä»¶**

```solidity
// ğŸ†• æ–°å¢ï¼šä»£å¸è®¾ç½®äº‹ä»¶
event TokenSet(address indexed token);

// ğŸ†• æ–°å¢ï¼šæ‰¹é‡é‡Šæ”¾ç»Ÿè®¡äº‹ä»¶
event BatchTokensReleasedByOwner(bytes32[] scheduleIds, uint256 totalAmount);

// ğŸ†• æ–°å¢ï¼šæš‚åœçŠ¶æ€äº‹ä»¶
event Paused(address account);
event Unpaused(address account);
```

**ä¼˜åŒ–çš„äº‹ä»¶**

```solidity
// ğŸ”„ ä¼˜åŒ–ï¼šæ›´è¯¦ç»†çš„å‚æ•°
event VestingScheduleCreated(
    bytes32 indexed scheduleId, 
    address indexed beneficiary, 
    uint256 amount,
    AllocationCategory indexed category  // ğŸ†• æ–°å¢åˆ†ç±»ç´¢å¼•
);

event TokensReleasedByOwner(
    bytes32 indexed scheduleId, 
    address indexed beneficiary, 
    uint256 amount,
    uint256 totalReleased  // ğŸ†• æ–°å¢ç´¯è®¡é‡Šæ”¾é‡‘é¢
);
```

---

## 3. MiningPool åˆçº¦ â­

### 3.1 åˆçº¦æ¦‚è¿°

MiningPool åˆçº¦æ˜¯ HZ Token ç”Ÿæ€ç³»ç»Ÿä¸­çš„æŒ–çŸ¿å¥–åŠ±åˆ†é…åˆçº¦ï¼Œè´Ÿè´£ç®¡ç†æŒ–çŸ¿æ”¶ç›Šçš„åˆ†é…å’Œç”¨æˆ·æç°åŠŸèƒ½ã€‚**ç‰ˆæœ¬ 2.1** å®ç°äº†é‡å¤§å®‰å…¨å¢å¼ºï¼Œä¿®å¤äº†å…³é”®æ¼æ´å¹¶å¼•å…¥äº†å¤šé¡¹åˆ›æ–°åŠŸèƒ½ã€‚

### 3.2 ğŸ›¡ï¸ å®‰å…¨æ¼æ´ä¿®å¤

#### 3.2.1 é—®é¢˜è¯†åˆ«

åŸæœ‰çš„å°é¢è‡ªåŠ¨å®¡æ‰¹æœºåˆ¶å­˜åœ¨ä¸¥é‡å®‰å…¨æ¼æ´ï¼š
- æ¶æ„ç”¨æˆ·å¯ä»¥é€šè¿‡é¢‘ç¹æäº¤å°é¢ç”³è¯·ç»•è¿‡å®¡æ ¸
- ç¼ºä¹è¯·æ±‚å†·å´æœŸå’Œæ¯æ—¥é™é¢æ§åˆ¶
- é“¾ä¸Šé“¾ä¸‹æ•°æ®å…³è”ä¸å¤Ÿä¸¥å¯†ï¼Œå­˜åœ¨é‡å¤ç”³è¯·é£é™©

#### 3.2.2 è§£å†³æ–¹æ¡ˆ

**åˆ†ç¦»è¯·æ±‚å’Œè½¬è´¦**ï¼šå°é¢æç°æ”¹ä¸º"è¯·æ±‚ â†’ é“¾ä¸‹å®¡æ ¸ â†’ æ‰¹é‡æ‰§è¡Œ"æµç¨‹

```solidity
// ç”¨æˆ·æäº¤è¯·æ±‚ï¼Œä¸ç«‹å³è½¬è´¦
function requestWithdrawal(uint256 amount, string calldata reason, uint256 offChainRecordId, uint256 nonce) external returns (uint256);

// é“¾ä¸‹å®¡æ ¸äººæ‰¹é‡æ‰§è¡Œ
function batchSmallTransfer(uint256[] calldata requestIds) external;
```

**å†·å´æœŸæœºåˆ¶**ï¼šé˜²æ­¢é¢‘ç¹ç”³è¯·

```solidity
mapping(address => uint256) public userLastRequestTime;
uint256 public requestCooldown = 1 hours;  // é»˜è®¤1å°æ—¶å†·å´æœŸ

modifier cooldownCheck() {
    require(block.timestamp >= userLastRequestTime[msg.sender] + requestCooldown, "MiningPool: cooldown period not met");
    userLastRequestTime[msg.sender] = block.timestamp;
    _;
}
```

**æ¯æ—¥é™é¢æ§åˆ¶**ï¼šåŒé‡é™é¢ä¿æŠ¤

```solidity
mapping(address => mapping(uint256 => uint256)) public userDailyWithdrawn;  // ç”¨æˆ·æ¯æ—¥æç°
mapping(uint256 => uint256) public globalDailyWithdrawn;  // å…¨å±€æ¯æ—¥æç°

uint256 public dailyUserLimit = 50000 * 10**18;    // ç”¨æˆ·æ—¥é™é¢
uint256 public dailyGlobalLimit = 1000000 * 10**18; // å…¨å±€æ—¥é™é¢
```

### 3.3 ğŸ”§ åˆ†å±‚IDç³»ç»Ÿ

#### 3.3.1 ç³»ç»Ÿè®¾è®¡

å®ç°äº†åˆ›æ–°çš„åˆ†å±‚IDç®¡ç†ç³»ç»Ÿï¼Œå»ºç«‹é“¾ä¸Šé“¾ä¸‹æ•°æ®çš„å¼ºå…³è”ï¼š

```solidity
struct IdManager {
    uint256 nextOnChainId;                          // ä¸‹ä¸€ä¸ªé“¾ä¸ŠID
    mapping(uint256 => uint256) offChainToOnChain;  // é“¾ä¸‹ID â†’ é“¾ä¸ŠID
    mapping(uint256 => uint256) onChainToOffChain;  // é“¾ä¸ŠID â†’ é“¾ä¸‹ID
    mapping(uint256 => bool) offChainIdExists;      // é“¾ä¸‹IDå­˜åœ¨æ€§
    mapping(bytes32 => bool) requestHashExists;     // è¯·æ±‚å“ˆå¸Œå­˜åœ¨æ€§
}

IdManager private idManager;
```

#### 3.3.2 é˜²é‡å¤æœºåˆ¶

```solidity
function _createIdMapping(uint256 offChainId, uint256 nonce) internal returns (uint256 onChainId) {
    // é˜²æ­¢é“¾ä¸‹IDé‡å¤
    require(!idManager.offChainIdExists[offChainId], "MiningPool: offchain ID already exists");
    
    // ç”Ÿæˆè¯·æ±‚å“ˆå¸Œé˜²æ­¢é‡å¤æäº¤
    bytes32 requestHash = keccak256(abi.encodePacked(msg.sender, offChainId, nonce, block.timestamp));
    require(!idManager.requestHashExists[requestHash], "MiningPool: duplicate request hash");
    
    // åˆ›å»ºåŒå‘æ˜ å°„
    onChainId = idManager.nextOnChainId++;
    idManager.offChainToOnChain[offChainId] = onChainId;
    idManager.onChainToOffChain[onChainId] = offChainId;
    idManager.offChainIdExists[offChainId] = true;
    idManager.requestHashExists[requestHash] = true;
    
    emit IdMappingCreated(onChainId, offChainId, requestHash);
}
```

### 3.4 ğŸ“Š ç»Ÿè®¡ç›‘æ§ç³»ç»Ÿ

#### 3.4.1 æ•°æ®ç»Ÿè®¡

```solidity
struct WithdrawalStatistics {
    uint256 totalWithdrawn;           // æ€»æå–ä»£å¸æ•°é‡
    uint256 totalMiningReleased;      // å·²é‡Šæ”¾æŒ–çŸ¿ä»£å¸æ€»æ•°
    uint256 smallWithdrawCount;       // å°é¢æç°æ¬¡æ•°
    uint256 mediumWithdrawCount;      // ä¸­é¢æç°æ¬¡æ•°
    uint256 largeWithdrawCount;       // å¤§é¢æç°æ¬¡æ•°
    uint256 totalRequestCount;        // æ€»è¯·æ±‚æ•°é‡
}

WithdrawalStatistics public stats;
```

#### 3.4.2 å®æ—¶æŸ¥è¯¢åŠŸèƒ½

```solidity
// æ‰¹é‡æŸ¥è¯¢è¯·æ±‚ä¿¡æ¯
function getBatchRequestInfo(uint256[] calldata requestIds) external view returns (WithdrawalRequest[] memory);

// éªŒè¯é“¾ä¸‹IDæœ‰æ•ˆæ€§
function validateOffChainIds(uint256[] calldata offChainIds) external view returns (bool[] memory valid, uint256[] memory onChainIds);

// æŸ¥è¯¢ç”¨æˆ·å‰©ä½™é™é¢
function getUserRemainingDailyLimit(address user) external view returns (uint256);
```

### 3.5 ğŸ§¹ è‡ªåŠ¨åŒ–ç®¡ç†

#### 3.5.1 è¿‡æœŸè¯·æ±‚æ¸…ç†

```solidity
function cleanupExpiredRequests(uint256[] calldata expiredIds) external {
    uint256 cleanedCount = 0;
    
    for (uint256 i = 0; i < expiredIds.length; i++) {
        WithdrawalRequest storage request = withdrawalRequests[expiredIds[i]];
        
        if (request.status == WithdrawalStatus.PENDING && 
            block.timestamp > request.timestamp + requestExpiryTime) {
            
            request.status = WithdrawalStatus.EXPIRED;
            cleanedCount++;
        }
    }
    
    emit ExpiredRequestsCleaned(msg.sender, cleanedCount);
}
```

### 3.6 ä¸‰çº§å®¡æ‰¹æœºåˆ¶

| å®¡æ‰¹ç­‰çº§ | é‡‘é¢èŒƒå›´ | å®¡æ‰¹æ–¹å¼ | å¤„ç†æ—¶é—´ | æ‰§è¡Œæ–¹å¼ |
|---------|---------|---------|---------|----------|
| **å°é¢** | < 1ä¸‡ä»£å¸ | è‡ªåŠ¨æ‰¹å‡† | å³æ—¶ | ç›´æ¥æ‰§è¡Œ |
| **ä¸­é¢** | 1-10ä¸‡ä»£å¸ | ä¸€çº§å®¡æ‰¹ | æ‰‹åŠ¨å®¡æ‰¹ | å®¡æ‰¹åæ‰§è¡Œ |
| **å¤§é¢** | > 10ä¸‡ä»£å¸ | äºŒçº§å®¡æ‰¹ | å¤šé‡å®¡æ‰¹ | å¤šçº§å®¡æ‰¹åæ‰§è¡Œ |

### 3.7 æ ¸å¿ƒæ•°æ®ç»“æ„

```solidity
// æç°ç”³è¯·ç»“æ„
struct WithdrawalRequest {
    uint256 id;             // ç”³è¯·ID
    address beneficiary;    // å—ç›Šäººåœ°å€
    uint256 amount;         // æç°é‡‘é¢
    ApprovalLevel level;    // å®¡æ‰¹çº§åˆ«
    WithdrawalStatus status; // ç”³è¯·çŠ¶æ€
    uint256 timestamp;      // æäº¤æ—¶é—´
    uint256 approvedAt;     // å®¡æ‰¹æ—¶é—´
    address approver1;      // ä¸€çº§å®¡æ‰¹äºº
    address approver2;      // äºŒçº§å®¡æ‰¹äºº
    string reason;          // ç”³è¯·åŸå› 
}

// å®¡æ‰¹çº§åˆ«æšä¸¾
enum ApprovalLevel {
    SMALL,    // å°é¢ < 1ä¸‡ä»£å¸
    MEDIUM,   // ä¸­é¢ 1-10ä¸‡ä»£å¸
    LARGE     // å¤§é¢ > 10ä¸‡ä»£å¸
}

// ç”³è¯·çŠ¶æ€æšä¸¾
enum WithdrawalStatus {
    PENDING,    // å¾…å®¡æ ¸
    EXECUTED,   // å·²æ‰§è¡Œ
    REJECTED    // å·²æ‹’ç»
}

contract MiningPool is Initializable, OwnableUpgradeable, ReentrancyGuardUpgradeable, Constants, IMiningPool {
    using SafeERC20Upgradeable for IERC20Upgradeable;

    // ERC20 ä»£å¸åˆçº¦
    IERC20Upgradeable private _token;
    
    // Vesting åˆçº¦
    IVesting private _vestingContract;
    
    // MiningPool åœ¨ Vesting åˆçº¦ä¸­çš„è®¡åˆ’ID
    bytes32 private _miningVestingScheduleId;
    
    // å®¡æ‰¹é˜ˆå€¼é…ç½®
    uint256 public smallAmountThreshold;   // å°é¢é˜ˆå€¼ï¼ˆè‡ªåŠ¨æ‰¹å‡†ï¼‰
    uint256 public mediumAmountThreshold;  // ä¸­é¢é˜ˆå€¼ï¼ˆéœ€è¦ä¸€çº§å®¡æ‰¹ï¼‰
    
    // å®¡æ‰¹äººå‘˜é…ç½®
    mapping(address => bool) public firstLevelApprovers;   // ä¸€çº§å®¡æ‰¹äºº
    mapping(address => bool) public secondLevelApprovers;  // äºŒçº§å®¡æ‰¹äºº
    
    // ææ¬¾ç”³è¯·å­˜å‚¨
    mapping(uint256 => WithdrawalRequest) public withdrawalRequests;
    uint256 public nextRequestId;
    
    // ç”¨æˆ·ç”³è¯·è®°å½•
    mapping(address => uint256[]) public userRequests;
    
    // ç»Ÿè®¡æ•°æ®
    uint256 public totalWithdrawn;
    uint256 public totalRequests;
    
    // ç‰ˆæœ¬æ§åˆ¶ï¼ˆç”¨äºå¯å‡çº§åˆçº¦ï¼‰
    uint256[50] private __gap;
}
```

### 3.8 ä¸‰çº§å®¡æ‰¹å®ç°

#### 3.8.1 æç°ç”³è¯·æäº¤

ç”¨æˆ·æäº¤æç°ç”³è¯·çš„å®Œæ•´å®ç°ï¼š

```solidity
function requestWithdrawal(uint256 amount, string calldata reason) external nonReentrant returns (uint256) {
    require(amount > 0, "MiningPool: amount must be greater than 0");
    
    // æ£€æŸ¥ Vesting åˆçº¦ä¸­çš„å¯é‡Šæ”¾é‡‘é¢
    uint256 releasableAmount = _vestingContract.computeReleasableAmount(_miningVestingScheduleId);
    require(amount <= releasableAmount, "MiningPool: insufficient releasable amount from vesting");
    
    // ç¡®å®šå®¡æ‰¹çº§åˆ«
    ApprovalLevel level = _determineApprovalLevel(amount);
    
    uint256 requestId = nextRequestId;
    
    // åˆ›å»ºææ¬¾ç”³è¯·
    WithdrawalRequest storage request = withdrawalRequests[requestId];
    request.id = requestId;
    request.beneficiary = _msgSender();
    request.amount = amount;
    request.level = level;
    request.status = WithdrawalStatus.PENDING;
    request.timestamp = block.timestamp;
    request.reason = reason;
    
    // è®°å½•ç”¨æˆ·ç”³è¯·
    userRequests[_msgSender()].push(requestId);
    totalRequests++;
    
    emit WithdrawalRequested(requestId, _msgSender(), amount, level);
    
    // å¦‚æœæ˜¯å°é¢ï¼Œè‡ªåŠ¨æ‰¹å‡†å¹¶æ‰§è¡Œ
    if (level == ApprovalLevel.SMALL) {
        _executeWithdrawal(requestId);
    }
    
    nextRequestId++;
    
    return requestId;
}

// è¾…åŠ©å‡½æ•°ï¼šç¡®å®šå®¡æ‰¹çº§åˆ«
function _determineApprovalLevel(uint256 amount) private view returns (ApprovalLevel) {
    if (amount <= smallAmountThreshold) {
        return ApprovalLevel.SMALL;
    } else if (amount <= mediumAmountThreshold) {
        return ApprovalLevel.MEDIUM;
    } else {
        return ApprovalLevel.LARGE;
    }
}
```

#### 3.8.2 ä¸­é¢æç°å®¡æ‰¹

ä¸­é¢æç°çš„äººå·¥å®¡æ‰¹å®ç°ï¼š

```solidity
function approveFirstLevel(uint256 requestId) external {
    require(firstLevelApprovers[_msgSender()], "MiningPool: not authorized first level approver");
    
    WithdrawalRequest storage request = withdrawalRequests[requestId];
    require(request.status == WithdrawalStatus.PENDING, "MiningPool: request not pending");
    require(request.level == ApprovalLevel.MEDIUM || request.level == ApprovalLevel.LARGE, 
            "MiningPool: invalid approval level");
    
    request.approver1 = _msgSender();
    
    emit WithdrawalApproved(requestId, _msgSender(), 1);
    
    // å¦‚æœæ˜¯ä¸­é¢ä¸”å·²è·å¾—ä¸€çº§å®¡æ‰¹ï¼Œæ‰§è¡Œææ¬¾
    if (request.level == ApprovalLevel.MEDIUM) {
        _executeWithdrawal(requestId);
    }
}
```

#### 3.8.3 æ‰¹é‡å¤„ç†åŠŸèƒ½

å°é¢æç°çš„æ‰¹é‡å¤„ç†å®ç°ï¼š

```solidity
function batchExecuteSmallWithdraws(bytes32[] calldata requestIds) 
    external onlyBatchExecutor whenNotPaused {
    
    uint256 totalAmount = 0;
    bytes32[] memory validRequestIds = new bytes32[](requestIds.length);
    uint256 validCount = 0;
    
    for (uint256 i = 0; i < requestIds.length; i++) {
        WithdrawRequest storage request = withdrawRequests[requestIds[i]];
        
        if (request.status == WithdrawStatus.PENDING && 
            request.wType == WithdrawType.SMALL) {
            
            request.status = WithdrawStatus.EXECUTED;
            totalAmount += request.amount;
            validRequestIds[validCount] = requestIds[i];
            validCount++;
            
            // è½¬è´¦ç»™ç”¨æˆ·
            hzToken.safeTransfer(request.user, request.amount);
            emit WithdrawExecuted(requestIds[i], request.user, request.amount);
        }
    }
    
    // åªè®°å½•æœ‰æ•ˆçš„è¯·æ±‚ID
    bytes32[] memory finalRequestIds = new bytes32[](validCount);
    for (uint256 i = 0; i < validCount; i++) {
        finalRequestIds[i] = validRequestIds[i];
    }
    
    emit BatchWithdrawExecuted(finalRequestIds, totalAmount);
}
```

---

## 4. Constants åˆçº¦

### 4.1 åˆçº¦æ¦‚è¿°

Constants åˆçº¦ç»Ÿä¸€ç®¡ç†ç³»ç»Ÿä¸­ä½¿ç”¨çš„æ‰€æœ‰å¸¸é‡å’Œé…ç½®å‚æ•°ã€‚

### 4.2 å¸¸é‡å®šä¹‰

```solidity
contract Constants {
    // ä»£å¸ç›¸å…³å¸¸é‡
    uint256 public constant TOTAL_SUPPLY = 10_000_000_000 * 10**18;
    uint256 public constant MINING_ALLOCATION = 5_000_000_000 * 10**18;
    uint256 public constant ECOSYSTEM_ALLOCATION = 2_000_000_000 * 10**18;
    uint256 public constant TEAM_ALLOCATION = 1_000_000_000 * 10**18;
    uint256 public constant INVESTOR_ALLOCATION = 2_000_000_000 * 10**18;
    
    // æ—¶é—´ç›¸å…³å¸¸é‡
    uint256 public constant TEAM_CLIFF_DURATION = 365 days;
    uint256 public constant TEAM_VESTING_DURATION = 2 * 365 days;
    uint256 public constant MINING_VESTING_DURATION = 6 * 365 days;
    uint256 public constant MONTH_SECONDS = 30 days;
    
    // æç°é˜ˆå€¼å¸¸é‡
    uint256 public constant SMALL_WITHDRAW_THRESHOLD = 10000;
    uint256 public constant LARGE_WITHDRAW_THRESHOLD = 100000;
    
    // ç¨ç‡ç›¸å…³å¸¸é‡
    uint256 public constant MAX_TAX_RATE = 500; // 5%
    uint256 public constant TAX_PRECISION = 10000;
    
    // è§’è‰²æ ‡è¯†ç¬¦
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
    bytes32 public constant BLACKLIST_MANAGER_ROLE = keccak256("BLACKLIST_MANAGER_ROLE");
}
```

---

## 5. æ¥å£å®šä¹‰

### 5.1 IHZToken æ¥å£

```solidity
interface IHZToken {
    // ERC-20 æ ‡å‡†æ¥å£
    function transfer(address to, uint256 amount) external returns (bool);
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
    function approve(address spender, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function allowance(address owner, address spender) external view returns (uint256);
    
    // æ‰©å±•åŠŸèƒ½æ¥å£
    function mint(address to, uint256 amount) external;
    function burn(uint256 amount) external;
    function burnFrom(address account, uint256 amount) external;
    function pause() external;
    function unpause() external;
    
    // ç®¡ç†åŠŸèƒ½æ¥å£
    function addToBlacklist(address account) external;
    function removeFromBlacklist(address account) external;
    function setTransactionTax(uint256 taxRate, address taxRecipient) external;
    function setTaxEnabled(bool enabled) external;
}
```

### 5.2 IVesting æ¥å£

```solidity
interface IVesting {
    // ç®¡ç†æ¥å£
    function createVestingSchedule(
        address beneficiary,
        uint256 start,
        uint256 cliff,
        uint256 duration,
        uint256 slicePeriodSeconds,
        bool revocable,
        uint256 amount
    ) external;
    
    function revoke(bytes32 vestingScheduleId) external;
    function releaseForBeneficiary(bytes32 vestingScheduleId, uint256 amount) external;
    
    // ç”¨æˆ·æ¥å£
    function release(bytes32 vestingScheduleId, uint256 amount) external;
    function setReleaseApproval(bytes32 vestingScheduleId, bool approved) external;
    
    // æŸ¥è¯¢æ¥å£
    function computeReleasableAmount(bytes32 vestingScheduleId) external view returns (uint256);
    function getVestingSchedule(bytes32 vestingScheduleId) external view returns (VestingSchedule memory);
    function getReleaseApproval(bytes32 vestingScheduleId) external view returns (bool);
}
```

### 5.3 IMiningPool æ¥å£

```solidity
interface IMiningPool {
    // ç”¨æˆ·æ¥å£
    function submitWithdrawRequest(uint256 points, bytes calldata signature) external returns (bytes32);
    function getUserRequests(address user) external view returns (bytes32[] memory);
    
    // ç®¡ç†æ¥å£
    function approveRequest(bytes32 requestId, bool approved) external;
    function batchExecuteSmallWithdraws(bytes32[] calldata requestIds) external;
    function executeLargeWithdraw(bytes32 requestId) external;
    
    // ç³»ç»Ÿæ¥å£
    function claimFromVesting(uint256 amount) external;
    function updateThresholds(uint256 smallThreshold, uint256 largeThreshold) external;
}
```

---

## 6. äº‹ä»¶ç³»ç»Ÿ

### 6.1 HZ Token äº‹ä»¶

```solidity
// ç®¡ç†äº‹ä»¶
event BlacklistAdded(address indexed account);
event BlacklistRemoved(address indexed account);
event TaxDeducted(address indexed from, uint256 amount);
event TaxConfigurationChanged(uint256 rate, address recipient, bool enabled);

// æƒé™äº‹ä»¶
event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
```

### 6.2 Vesting äº‹ä»¶

```solidity
// æ ¸å¿ƒäº‹ä»¶
event VestingScheduleCreated(bytes32 indexed vestingScheduleId, address indexed beneficiary, uint256 amount);
event TokensReleased(bytes32 indexed vestingScheduleId, address indexed beneficiary, uint256 amount);
event VestingScheduleRevoked(bytes32 indexed vestingScheduleId, address indexed beneficiary, uint256 unreleased);

// ä»£ç†é‡Šæ”¾äº‹ä»¶
event TokensReleasedByOwner(bytes32 indexed vestingScheduleId, address indexed beneficiary, uint256 amount);
event BatchTokensReleasedByOwner(bytes32[] vestingScheduleIds, uint256 totalAmount);

// åˆ†é…ç±»å‹äº‹ä»¶
event VestingScheduleCreatedWithCategory(bytes32 indexed vestingScheduleId, address indexed beneficiary, uint256 amount, AllocationCategory category);
```

### 6.3 MiningPool äº‹ä»¶

```solidity
// æç°äº‹ä»¶
event WithdrawRequestSubmitted(bytes32 indexed requestId, address indexed user, uint256 amount, WithdrawType wType);
event WithdrawRequestProcessed(bytes32 indexed requestId, bool approved);
event WithdrawExecuted(bytes32 indexed requestId, address indexed user, uint256 amount);

// æ‰¹é‡å¤„ç†äº‹ä»¶
event BatchWithdrawExecuted(bytes32[] requestIds, uint256 totalAmount);

// ç®¡ç†äº‹ä»¶
event ThresholdsUpdated(uint256 smallThreshold, uint256 largeThreshold);
event TokensClaimed(uint256 amount);
```

---

## 7. éƒ¨ç½²é…ç½®

### 7.1 éƒ¨ç½²é¡ºåº

åˆçº¦å¿…é¡»æŒ‰ä»¥ä¸‹é¡ºåºéƒ¨ç½²ä»¥ç¡®ä¿ä¾èµ–å…³ç³»æ­£ç¡®ï¼š

```
1. Constants.sol       (ç³»ç»Ÿå¸¸é‡)
   â†“
2. HZ Token.sol       (æ ¸å¿ƒä»£å¸åˆçº¦)  
   â†“
3. Vesting.sol        (é‡Šæ”¾ç®¡ç†åˆçº¦)
   â†“
4. MiningPool.sol     (æŒ–çŸ¿ç®¡ç†åˆçº¦)
   â†“
5. æƒé™é…ç½®å’Œå…³è”è®¾ç½®
   â†“
6. ä»£å¸é“¸é€ å’Œåˆå§‹åŒ–
```

### 7.2 å¯å‡çº¦åˆçº¦éƒ¨ç½²

æ‰€æœ‰åˆçº¦éƒ½é‡‡ç”¨ OpenZeppelin çš„å¯å‡çº§ä»£ç†æ¨¡å¼ï¼š

```javascript
// ä½¿ç”¨ @openzeppelin/hardhat-upgrades æ’ä»¶
const { upgrades } = require('@openzeppelin/hardhat-upgrades');

// 1. éƒ¨ç½²å¯å‡çº§åˆçº¦
const constants = await Constants.deploy(); // Constants ä¸éœ€è¦å‡çº§

// éƒ¨ç½²å¯å‡çº§ HZ Token
const HZToken = await ethers.getContractFactory("HZToken");
const hzToken = await upgrades.deployProxy(
    HZToken, 
    ["HZ Token", "HZ"], 
    { initializer: 'initialize' }
);

// éƒ¨ç½²å¯å‡çº§ Vesting
const Vesting = await ethers.getContractFactory("Vesting");
const vesting = await upgrades.deployProxy(
    Vesting,
    [hzToken.address],
    { initializer: 'initialize' }
);

// éƒ¨ç½²å¯å‡çº§ MiningPool
const MiningPool = await ethers.getContractFactory("MiningPool");
const miningPool = await upgrades.deployProxy(
    MiningPool,
    [vesting.address, hzToken.address, multiSigWallet.address],
    { initializer: 'initialize' }
);

// 2. æƒé™é…ç½®
const MINTER_ROLE = await hzToken.MINTER_ROLE();
const PAUSER_ROLE = await hzToken.PAUSER_ROLE();

await hzToken.grantRole(MINTER_ROLE, owner.address);
await hzToken.grantRole(PAUSER_ROLE, admin.address);

// 3. é“¸é€ ä»£å¸åˆ° Vesting åˆçº¦
const totalSupply = ethers.utils.parseEther("10000000000"); // 100äº¿
await hzToken.mint(vesting.address, totalSupply);

// 4. åˆ›å»º Vesting è®¡åˆ’ï¼ˆå¸¦åˆ†é…ç±»å‹æ ‡è¯†ï¼‰
// æŒ–çŸ¿å¥–åŠ±è®¡åˆ’
await vesting.createVestingSchedule(
    miningPool.address,      // å—ç›Šäºº
    Math.floor(Date.now() / 1000), // ç«‹å³å¼€å§‹
    0,                       // æ—  cliff
    6 * 365 * 24 * 3600,    // 6å¹´
    30 * 24 * 3600,         // 30å¤©é—´éš”
    false,                   // ä¸å¯æ’¤é”€
    ethers.utils.parseEther("5000000000"), // 50äº¿ä»£å¸
    0 // AllocationCategory.MINING
);

// è¿è¥ä¸ç”Ÿæ€å‘å±•è®¡åˆ’
await vesting.createVestingSchedule(
    ecosystemWallet.address,
    Math.floor(Date.now() / 1000),
    0,
    5 * 365 * 24 * 3600,    // 5å¹´
    30 * 24 * 3600,
    true,                    // å¯æ’¤é”€
    ethers.utils.parseEther("2000000000"), // 20äº¿ä»£å¸
    1 // AllocationCategory.ECOSYSTEM
);

// å›¢é˜Ÿæ¿€åŠ±è®¡åˆ’
await vesting.createVestingSchedule(
    teamWallet.address,
    Math.floor(Date.now() / 1000),
    365 * 24 * 3600,        // 1å¹´ cliff
    3 * 365 * 24 * 3600,    // 3å¹´æ€»å‘¨æœŸ
    30 * 24 * 3600,
    true,
    ethers.utils.parseEther("1000000000"), // 10äº¿ä»£å¸
    2 // AllocationCategory.TEAM
);
```

---

## 8. å¸¸è§é—®é¢˜

### 8.1 ä»£å¸ç»æµé—®é¢˜

**Q1: è¿è¥ä¸ç”Ÿæ€å‘å±•çš„é‡Šæ”¾è®¡ç®—æ˜¯å¦æ­£ç¡®ï¼Ÿ**

A1: åŸè®¾è®¡ä¸­ç¡®å®å­˜åœ¨æ•°å­¦ä¸åŒ¹é…é—®é¢˜ã€‚ç°å·²ä¿®æ­£ä¸ºï¼š
- ç¬¬1å¹´ï¼šæ¯æœˆ1äº¿HZ Ã— 12ä¸ªæœˆ = 12äº¿HZ (60%)
- ç¬¬2-5å¹´ï¼šæ¯æœˆçº¦1667ä¸‡HZ Ã— 48ä¸ªæœˆ = 8äº¿HZ (40%)
- æ€»è®¡ï¼š20äº¿HZ (100%)

**Q2: ä¸ºä»€ä¹ˆé€‰æ‹©18ä½å°æ•°ç²¾åº¦ï¼Ÿ**

A2: é€‰æ‹©18ä½å°æ•°çš„åŸå› ï¼š
- ä¸ETHã€USDTç­‰ä¸»æµä»£å¸ä¿æŒä¸€è‡´
- æä¾›è¶³å¤Ÿçš„ç²¾åº¦æ”¯æŒå°é¢äº¤æ˜“
- å…¼å®¹å¤§å¤šæ•°DeFiåè®®å’Œäº¤æ˜“æ‰€
- ç¬¦åˆè¡Œä¸šæ ‡å‡†å’Œç”¨æˆ·ä¹ æƒ¯

### 8.2 æŠ€æœ¯å®ç°é—®é¢˜

**Q3: äº¤æ˜“ç¨åŠŸèƒ½çš„å…·ä½“ç”¨é€”æ˜¯ä»€ä¹ˆï¼Ÿ**

A3: äº¤æ˜“ç¨åŠŸèƒ½ä¸»è¦ç”¨äºï¼š
- **ç”Ÿæ€å»ºè®¾åŸºé‡‘**: æ‰‹ç»­è´¹ç”¨äºé¡¹ç›®å‘å±•
- **æµåŠ¨æ€§æŒ–çŸ¿å¥–åŠ±**: æ¿€åŠ±æä¾›æµåŠ¨æ€§çš„ç”¨æˆ·
- **ä»£å¸å›è´­é”€æ¯**: å‡å°‘æµé€šä¾›åº”é‡ï¼Œæ”¯æ’‘ä»£å¸ä»·å€¼
- **åæœºå™¨äººäº¤æ˜“**: é€šè¿‡ç¨æ”¶æœºåˆ¶é˜»æ­¢æœºå™¨äººé¢‘ç¹äº¤æ˜“

**Q4: MiningPool çš„ä¸‰çº§å®¡æ‰¹æœºåˆ¶å¦‚ä½•å·¥ä½œï¼Ÿ**

A4: 
- **å°é¢æç°** (< 1ä¸‡ç§¯åˆ†): è‡ªåŠ¨è¿›å…¥æ‰¹é‡å¤„ç†é˜Ÿåˆ—ï¼Œ24å°æ—¶å†…æ‰¹é‡æ‰§è¡Œ
- **ä¸­é¢æç°** (1-10ä¸‡ç§¯åˆ†): éœ€è¦å®¡æ‰¹å‘˜å•ç‹¬å®¡æ‰¹åç«‹å³æ‰§è¡Œ
- **å¤§é¢æç°** (> 10ä¸‡ç§¯åˆ†): éœ€è¦å¤šé‡ç­¾åé’±åŒ…å®¡æ‰¹æ‰§è¡Œ

### 8.3 å®‰å…¨æ€§é—®é¢˜

**Q5: å¦‚ä½•ç¡®ä¿å¤šé‡ç­¾åçš„å®‰å…¨æ€§ï¼Ÿ**

A5: å¤šé‡ç­¾åå®‰å…¨æªæ–½ï¼š
- **åˆ†æ•£ç­¾åæƒ**: ç­¾åæƒåˆ†æ•£ç»™ä¸åŒçš„å¯ä¿¡äººå‘˜
- **ç¡¬ä»¶é’±åŒ…**: ä½¿ç”¨ç¡¬ä»¶é’±åŒ…ä¿æŠ¤ç§é’¥å®‰å…¨
- **æ—¶é—´é”æœºåˆ¶**: é‡è¦æ“ä½œè®¾ç½®å»¶è¿Ÿæ‰§è¡ŒæœŸ
- **é€æ˜ç›‘ç£**: æ‰€æœ‰å¤šç­¾æ“ä½œéƒ½æœ‰å®Œæ•´çš„é“¾ä¸Šè®°å½•

**Q6: Owner ç›´æ¥ä»£ç†é‡Šæ”¾æ˜¯å¦å®‰å…¨ï¼Ÿ**

A6: æ–°çš„ä»£ç†é‡Šæ”¾æœºåˆ¶çš„å®‰å…¨ä¿éšœï¼š
- **åªèƒ½é‡Šæ”¾å·²è§£é”ä»£å¸**: Owner ä¸èƒ½æå‰é‡Šæ”¾æœªåˆ°æœŸçš„ä»£å¸
- **å®Œæ•´äº‹ä»¶æ—¥å¿—**: æ‰€æœ‰ä»£ç†é‡Šæ”¾æ“ä½œéƒ½æœ‰å®Œæ•´è®°å½•
- **å¤šç­¾æ§åˆ¶**: Owner æƒé™ç”±å¤šé‡ç­¾åé’±åŒ…æ§åˆ¶
- **æ—¶é—´é”æœºåˆ¶**: é‡è¦æ“ä½œå¯è®¾ç½®æ—¶é—´é”
- **åˆçº¦å¯å‡çº§**: å¯ä»¥é€šè¿‡å‡çº§æ¥ä¿®å¤æ½œåœ¨é—®é¢˜

**Q7: å¯å‡çº§åˆçº¦çš„å®‰å…¨æ€§å¦‚ä½•ä¿è¯ï¼Ÿ**

A7: å¯å‡çº§åˆçº¦å®‰å…¨æªæ–½ï¼š
- **æ—¶é—´é”å‡çº§**: æ‰€æœ‰å‡çº§æ“ä½œéƒ½æœ‰ 48 å°æ—¶çš„æ—¶é—´é”
- **å¤šç­¾å‡çº§**: å‡çº§æ“ä½œéœ€è¦å¤šé‡ç­¾åç¡®è®¤
- **ç¤¾åŒºç›‘ç£**: å‡çº§ææ¡ˆå…¬å¼€ï¼Œæ¥å—ç¤¾åŒºç›‘ç£
- **å­˜å‚¨æ§½ä¿æŠ¤**: ä½¿ç”¨ Storage Gap ä¿è¯å‡çº§å…¼å®¹æ€§
- **ç‰ˆæœ¬æ§åˆ¶**: ä¸¥æ ¼çš„ç‰ˆæœ¬ç®¡ç†å’Œå›æ»šæœºåˆ¶

---

## æŠ€æœ¯å®ç°æ€»ç»“

### æ ¸å¿ƒæŠ€æœ¯ç‰¹ç‚¹

1. **æ¨¡å—åŒ–è®¾è®¡**: æ¯ä¸ªåˆçº¦èŒè´£å•ä¸€ï¼Œä¾¿äºç»´æŠ¤å’Œå‡çº§
2. **å®‰å…¨ä¼˜å…ˆ**: å¤šé‡éªŒè¯æœºåˆ¶ï¼Œé˜²æ­¢å„ç§æ”»å‡»
3. **Gas ä¼˜åŒ–**: æ‰¹é‡æ“ä½œå’Œå­˜å‚¨ä¼˜åŒ–å‡å°‘æˆæœ¬
4. **äº‹ä»¶å®Œæ•´**: æ‰€æœ‰å…³é”®æ“ä½œéƒ½æœ‰äº‹ä»¶è®°å½•
5. **æ¥å£æ ‡å‡†**: æ ‡å‡†åŒ–æ¥å£ä¾¿äºé›†æˆ

### ä»£ç è´¨é‡ä¿è¯

1. **NatSpec æ–‡æ¡£**: å®Œæ•´çš„å‡½æ•°å’Œå‚æ•°è¯´æ˜
2. **è¾“å…¥éªŒè¯**: ä¸¥æ ¼çš„å‚æ•°æ£€æŸ¥å’Œè¾¹ç•ŒéªŒè¯
3. **é”™è¯¯å¤„ç†**: æ¸…æ™°çš„é”™è¯¯ä¿¡æ¯å’Œå¼‚å¸¸å¤„ç†
4. **æµ‹è¯•è¦†ç›–**: 100% çš„å•å…ƒæµ‹è¯•è¦†ç›–
5. **é™æ€åˆ†æ**: ä½¿ç”¨ Slither ç­‰å·¥å…·æ£€æŸ¥

---

**ç›¸å…³æ–‡æ¡£**:
- [ç³»ç»Ÿæ¶æ„è®¾è®¡](./0.Architecture.md)
- [ä»£å¸ç»æµæ¨¡å‹](./1.Tokenomics.md)
- [éƒ¨ç½²æŒ‡å—](./3.Deployment.md)
- [å®‰å…¨æœºåˆ¶](./4.Security.md)
- [å¸¸è§é—®é¢˜è§£ç­”](./5.FAQ.md)

---

*æ–‡æ¡£ç‰ˆæœ¬: v2.1*  
*æœ€åæ›´æ–°: 2025å¹´8æœˆ4æ—¥*
*åŒ…å«å®‰å…¨å¢å¼ºã€åŠ¨æ€ç¨æ”¶ç³»ç»Ÿã€åˆ†å±‚IDç®¡ç†ç­‰é‡å¤§æ›´æ–°*