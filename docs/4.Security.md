# HZ Token å®‰å…¨æœºåˆ¶

## æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†æè¿° HZ Token ç”Ÿæ€ç³»ç»Ÿçš„å®‰å…¨è®¾è®¡ï¼ŒåŒ…æ‹¬å¨èƒåˆ†æã€é˜²æŠ¤æœºåˆ¶ã€åº”æ€¥å“åº”å’Œæœ€ä½³å®è·µã€‚

**æ–‡æ¡£ç‰ˆæœ¬**: v2.1  
**æœ€åæ›´æ–°**: 2025å¹´8æœˆ4æ—¥

> ğŸ›¡ï¸ **é‡å¤§å®‰å…¨æ›´æ–°**: æœ¬ç‰ˆæœ¬ä¿®å¤äº† MiningPool çš„å…³é”®å®‰å…¨æ¼æ´ï¼Œæ–°å¢äº†åŠ¨æ€ç¨æ”¶é˜²æŠ¤ã€åˆ†å±‚IDç®¡ç†ç­‰å¤šé¡¹å®‰å…¨æœºåˆ¶ã€‚è¯¦ç»†æƒ…å†µè¯·å‚é˜… [æ›´æ–°æ—¥å¿—](./6.Updates.md)ã€‚

---

## ç›®å½•

1. [å®‰å…¨æ¶æ„](#1-å®‰å…¨æ¶æ„)
2. [å¨èƒæ¨¡å‹](#2-å¨èƒæ¨¡å‹)
3. [é˜²æŠ¤æœºåˆ¶](#3-é˜²æŠ¤æœºåˆ¶)
4. [ğŸ›¡ï¸ å®‰å…¨æ¼æ´ä¿®å¤](#4-å®‰å…¨æ¼æ´ä¿®å¤)
5. [ğŸ”§ æ–°å¢å®‰å…¨æœºåˆ¶](#5-æ–°å¢å®‰å…¨æœºåˆ¶)
6. [æƒé™ç®¡ç†](#6-æƒé™ç®¡ç†)
7. [åº”æ€¥å“åº”](#7-åº”æ€¥å“åº”)
8. [å®¡è®¡å’Œç›‘æ§](#8-å®¡è®¡å’Œç›‘æ§)

---

## 1. å®‰å…¨æ¶æ„

### 1.1 çºµæ·±é˜²å¾¡ä½“ç³»

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     å®‰å…¨é˜²æŠ¤å±‚æ¬¡                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚   åº”ç”¨å±‚     â”‚  â”‚   ä¸šåŠ¡å±‚     â”‚  â”‚    æ•°æ®å±‚        â”‚   â”‚
â”‚  â”‚ å‰ç«¯å®‰å…¨     â”‚  â”‚ é€»è¾‘éªŒè¯     â”‚  â”‚  å­˜å‚¨å®‰å…¨        â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚   åˆçº¦å±‚     â”‚  â”‚   åè®®å±‚     â”‚  â”‚    ç½‘ç»œå±‚        â”‚   â”‚
â”‚  â”‚ æ™ºèƒ½åˆçº¦å®‰å…¨  â”‚  â”‚ ERC-20å®‰å…¨   â”‚  â”‚  ç½‘ç»œæ”»å‡»é˜²æŠ¤     â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚   åŸºç¡€å±‚     â”‚  â”‚   ç¡¬ä»¶å±‚     â”‚  â”‚    ç‰©ç†å±‚        â”‚   â”‚
â”‚  â”‚ åŒºå—é“¾å®‰å…¨   â”‚  â”‚ é’±åŒ…å®‰å…¨     â”‚  â”‚  ç¯å¢ƒå®‰å…¨        â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 å®‰å…¨è®¾è®¡åŸåˆ™

**æœ€å°æƒé™åŸåˆ™**
- æ¯ä¸ªè§’è‰²åªè·å¾—å¿…è¦çš„æœ€å°æƒé™
- æƒé™åˆ†ç¦»å’ŒèŒè´£åˆ†å·¥
- å®šæœŸå®¡æŸ¥å’Œè°ƒæ•´æƒé™

**çºµæ·±é˜²å¾¡**
- å¤šå±‚å®‰å…¨æ§åˆ¶æœºåˆ¶
- å•ç‚¹å¤±æ•ˆä¸å½±å“æ•´ä½“å®‰å…¨
- å†—ä½™ä¿æŠ¤æªæ–½

**å®‰å…¨é»˜è®¤**
- é»˜è®¤æ‹’ç»æ‰€æœ‰æœªæ˜ç¡®å…è®¸çš„æ“ä½œ
- å®‰å…¨é…ç½®ä½œä¸ºé»˜è®¤è®¾ç½®
- ä¿å®ˆçš„å‚æ•°è®¾ç½®

**é€æ˜æ€§**
- æ‰€æœ‰å®‰å…¨ç›¸å…³æ“ä½œè®°å½•äº‹ä»¶
- å…¬å¼€é€æ˜çš„å®‰å…¨æœºåˆ¶
- å¯å®¡è®¡çš„æ“ä½œå†å²

---

## 2. å¨èƒæ¨¡å‹

### 2.1 å¨èƒåˆ†ç±»

#### 2.1.1 æ™ºèƒ½åˆçº¦å¨èƒ

| å¨èƒç±»å‹ | é£é™©ç­‰çº§ | æ”»å‡»å‘é‡ | å½±å“èŒƒå›´ |
|----------|----------|----------|----------|
| é‡å…¥æ”»å‡» | é«˜ | æ¶æ„åˆçº¦å›è°ƒ | èµ„é‡‘æŸå¤± |
| æ•´æ•°æº¢å‡º | ä¸­ | æ•°å€¼è¾¹ç•Œæ”»å‡» | çŠ¶æ€å¼‚å¸¸ |
| æƒé™ç»•è¿‡ | é«˜ | æƒé™éªŒè¯æ¼æ´ | æœªæˆæƒæ“ä½œ |
| æ‹’ç»æœåŠ¡ | ä¸­ | Gas è€—å°½æ”»å‡» | æœåŠ¡ä¸­æ–­ |
| å‰ç«¯è¿è¡Œ | ä¸­ | äº¤æ˜“é¡ºåºæ“çºµ | ç»æµæŸå¤± |

#### 2.1.2 ç»æµå¨èƒ

| å¨èƒç±»å‹ | é£é™©ç­‰çº§ | æ”»å‡»æ–¹å¼ | å½±å“ |
|----------|----------|----------|------|
| é—ªç”µè´·æ”»å‡» | é«˜ | ä»·æ ¼æ“çºµ | å¥—åˆ©æŸå¤± |
| å¤§é¢æŠ›å”® | ä¸­ | é›†ä¸­æŠ›å”® | ä»·æ ¼æ³¢åŠ¨ |
| æµåŠ¨æ€§æ”»å‡» | ä¸­ | æµåŠ¨æ€§æŠ½å– | å¸‚åœºå¤±è¡¡ |
| æ²»ç†æ”»å‡» | é«˜ | æ¶æ„ææ¡ˆ | ç³»ç»Ÿæ§åˆ¶ |

#### 2.1.3 è¿è¥å¨èƒ

| å¨èƒç±»å‹ | é£é™©ç­‰çº§ | é£é™©æº | ç¼“è§£æªæ–½ |
|----------|----------|--------|----------|
| ç§é’¥æ³„éœ² | é«˜ | äººä¸ºå› ç´  | å¤šç­¾+ç¡¬ä»¶é’±åŒ… |
| å†…éƒ¨æ”»å‡» | ä¸­ | å†…éƒ¨äººå‘˜ | æƒé™åˆ†ç¦» |
| ç¤¾å·¥æ”»å‡» | ä¸­ | æ¬ºéª—æ‰‹æ®µ | å®‰å…¨åŸ¹è®­ |
| ä¾›åº”é“¾æ”»å‡» | ä¸­ | ç¬¬ä¸‰æ–¹ä¾èµ– | ä»£ç å®¡è®¡ |

### 2.2 æ”»å‡»åœºæ™¯åˆ†æ

**åœºæ™¯1: é‡å…¥æ”»å‡»**
```solidity
// æ½œåœ¨æ¼æ´ä»£ç  (å·²ä¿®å¤)
function withdraw(uint256 amount) external {
    require(balances[msg.sender] >= amount);
    
    // å±é™©: åœ¨çŠ¶æ€æ›´æ–°å‰è¿›è¡Œå¤–éƒ¨è°ƒç”¨
    (bool success, ) = msg.sender.call{value: amount}("");
    require(success);
    
    balances[msg.sender] -= amount; // çŠ¶æ€æ›´æ–°å¤ªæ™š
}

// å®‰å…¨ä¿®å¤ç‰ˆæœ¬
function withdraw(uint256 amount) external nonReentrant {
    require(balances[msg.sender] >= amount);
    
    // å…ˆæ›´æ–°çŠ¶æ€
    balances[msg.sender] -= amount;
    
    // å†è¿›è¡Œå¤–éƒ¨è°ƒç”¨
    (bool success, ) = msg.sender.call{value: amount}("");
    require(success);
}
```

**åœºæ™¯2: æƒé™ç»•è¿‡æ”»å‡»**
```solidity
// æ½œåœ¨æ¼æ´
modifier onlyOwner() {
    require(msg.sender == owner); // ç®€å•çš„åœ°å€æ£€æŸ¥
    _;
}

// å®‰å…¨ç‰ˆæœ¬
modifier onlyOwner() {
    require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), "Not authorized");
    _;
}
```

---

## 3. é˜²æŠ¤æœºåˆ¶

### 3.1 æ™ºèƒ½åˆçº¦å®‰å…¨

#### 3.1.1 é‡å…¥æ”»å‡»é˜²æŠ¤

```solidity
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract HZToken is ReentrancyGuard {
    mapping(address => uint256) private _balances;
    
    function transfer(address to, uint256 amount) 
        external 
        nonReentrant 
        returns (bool) {
        
        _balances[msg.sender] -= amount;
        _balances[to] += amount;
        
        // å¤–éƒ¨è°ƒç”¨æ”¾åœ¨çŠ¶æ€æ›´æ–°ä¹‹å
        emit Transfer(msg.sender, to, amount);
        return true;
    }
}
```

#### 3.1.2 æ•´æ•°æº¢å‡ºé˜²æŠ¤

```solidity
// Solidity 0.8+ å†…ç½®æº¢å‡ºæ£€æŸ¥
contract SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        // è‡ªåŠ¨æ£€æŸ¥æº¢å‡ºï¼Œæ— éœ€ SafeMath åº“
        return a + b;
    }
    
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        // è‡ªåŠ¨æ£€æŸ¥ä¸‹æº¢
        return a - b;
    }
}
```

#### 3.1.3 è®¿é—®æ§åˆ¶

```solidity
import "@openzeppelin/contracts/access/AccessControl.sol";

contract SecureContract is AccessControl {
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
    
    modifier onlyMinter() {
        require(hasRole(MINTER_ROLE, msg.sender), "Not minter");
        _;
    }
    
    modifier onlyPauser() {
        require(hasRole(PAUSER_ROLE, msg.sender), "Not pauser");
        _;
    }
    
    function mint(address to, uint256 amount) external onlyMinter {
        _mint(to, amount);
    }
}
```

### 3.2 è¾“å…¥éªŒè¯

```solidity
contract InputValidation {
    modifier validAddress(address addr) {
        require(addr != address(0), "Zero address");
        require(addr != address(this), "Self address");
        _;
    }
    
    modifier validAmount(uint256 amount) {
        require(amount > 0, "Zero amount");
        require(amount <= MAX_AMOUNT, "Exceeds maximum");
        _;
    }
    
    function transfer(address to, uint256 amount) 
        external 
        validAddress(to) 
        validAmount(amount) 
        returns (bool) {
        // å®‰å…¨çš„è½¬è´¦é€»è¾‘
    }
}
```

### 3.3 çŠ¶æ€ç®¡ç†

```solidity
import "@openzeppelin/contracts/security/Pausable.sol";

contract PausableToken is Pausable {
    mapping(address => bool) private _blacklist;
    
    modifier notBlacklisted(address account) {
        require(!_blacklist[account], "Blacklisted");
        _;
    }
    
    function transfer(address to, uint256 amount) 
        external 
        whenNotPaused 
        notBlacklisted(msg.sender)
        notBlacklisted(to)
        returns (bool) {
        // è½¬è´¦é€»è¾‘
    }
    
    function pause() external onlyRole(PAUSER_ROLE) {
        _pause();
    }
}
```

---

## 4. ğŸ›¡ï¸ å®‰å…¨æ¼æ´ä¿®å¤

### 4.1 MiningPool å…³é”®æ¼æ´ä¿®å¤ â­

#### 4.1.1 æ¼æ´æè¿°

**é—®é¢˜**: åŸæœ‰çš„å°é¢è‡ªåŠ¨å®¡æ‰¹æœºåˆ¶å­˜åœ¨ä¸¥é‡å®‰å…¨æ¼æ´ï¼Œæ¶æ„ç”¨æˆ·å¯ä»¥é€šè¿‡é¢‘ç¹æäº¤å°é¢ç”³è¯·è¾¾åˆ°ç»•è¿‡å®¡æ ¸å’Œæ‘§ç©ºèµ„é‡‘æ± çš„ç›®çš„ã€‚

**æ”»å‡»å‘é‡**:
- é¢‘ç¹æäº¤å°é¢æç°ç”³è¯·
- ç¼ºä¹å†·å´æœŸå’Œé™é¢æ§åˆ¶
- é“¾ä¸Šé“¾ä¸‹æ•°æ®å…³è”ä¸å¤Ÿä¸¥å¯†

#### 4.1.2 ä¿®å¤æ–¹æ¡ˆ

**1. åˆ†ç¦»è¯·æ±‚å’Œè½¬è´¦**

```solidity
// åŸæœ‰çš„å±é™©ä»£ç ï¼ˆå·²ä¿®å¤ï¼‰
function requestWithdrawal(uint256 amount) external {
    if (amount <= smallAmountThreshold) {
        // å±é™©ï¼šç«‹å³è½¬è´¦ï¼Œå¯è¢«æ¶æ„åˆ©ç”¨
        _token.transfer(msg.sender, amount);
    }
}

// ä¿®å¤åçš„å®‰å…¨ä»£ç 
function requestWithdrawal(
    uint256 amount, 
    string calldata reason, 
    uint256 offChainRecordId, 
    uint256 nonce
) external cooldownCheck dailyLimitCheck returns (uint256) {
    // åªåˆ›å»ºè¯·æ±‚ï¼Œä¸ç«‹å³è½¬è´¦
    uint256 requestId = _createWithdrawalRequest(amount, reason, offChainRecordId, nonce);
    
    // å°é¢è¯·æ±‚éœ€è¦é“¾ä¸‹å®¡æ ¸åæ‰¹é‡æ‰§è¡Œ
    if (amount <= smallAmountThreshold) {
        // ä¸å†ç«‹å³è½¬è´¦ï¼Œç­‰å¾…é“¾ä¸‹å®¡æ ¸
        emit SmallWithdrawalRequested(requestId, msg.sender, amount);
    }
    
    return requestId;
}
```

**2. å†·å´æœŸæœºåˆ¶**

```solidity
mapping(address => uint256) public userLastRequestTime;
uint256 public requestCooldown = 1 hours;  // é»˜è®¤1å°æ—¶å†·å´æœŸ

modifier cooldownCheck() {
    require(
        block.timestamp >= userLastRequestTime[msg.sender] + requestCooldown,
        "MiningPool: cooldown period not met"
    );
    userLastRequestTime[msg.sender] = block.timestamp;
    _;
}
```

**3. æ¯æ—¥é™é¢æ§åˆ¶**

```solidity
// ç”¨æˆ·æ¯æ—¥æç°è®°å½•
mapping(address => mapping(uint256 => uint256)) public userDailyWithdrawn;
// å…¨å±€æ¯æ—¥æç°è®°å½•
mapping(uint256 => uint256) public globalDailyWithdrawn;

uint256 public dailyUserLimit = 50000 * 10**18;    // ç”¨æˆ·æ—¥é™é¢
uint256 public dailyGlobalLimit = 1000000 * 10**18; // å…¨å±€æ—¥é™é¢

modifier dailyLimitCheck(uint256 amount) {
    uint256 today = block.timestamp / 1 days;
    
    // æ£€æŸ¥ç”¨æˆ·æ¯æ—¥é™é¢
    require(
        userDailyWithdrawn[msg.sender][today] + amount <= dailyUserLimit,
        "MiningPool: exceeds daily user limit"
    );
    
    // æ£€æŸ¥å…¨å±€æ¯æ—¥é™é¢
    require(
        globalDailyWithdrawn[today] + amount <= dailyGlobalLimit,
        "MiningPool: exceeds daily global limit"
    );
    
    _;
}
```

**4. é“¾ä¸‹å®¡æ ¸æ‰¹é‡æ‰§è¡Œ**

```solidity
// é“¾ä¸‹å®¡æ ¸äººæ‰¹é‡å¤„ç†å°é¢æç°
function batchSmallTransfer(uint256[] calldata requestIds) 
    external onlyOffChainAuditor {
    
    uint256 totalAmount = 0;
    
    for (uint256 i = 0; i < requestIds.length; i++) {
        WithdrawalRequest storage request = withdrawalRequests[requestIds[i]];
        
        require(request.status == WithdrawalStatus.PENDING, "Invalid status");
        require(request.level == ApprovalLevel.SMALL, "Not small amount");
        
        // æ‰§è¡Œè½¬è´¦
        _token.safeTransfer(request.beneficiary, request.amount);
        request.status = WithdrawalStatus.EXECUTED;
        
        totalAmount += request.amount;
        
        emit WithdrawalExecuted(requestIds[i], request.beneficiary, request.amount);
    }
    
    emit BatchSmallTransfer(msg.sender, totalAmount, requestIds.length);
}
```

### 4.2 åŠ¨æ€äº¤æ˜“ç¨å®‰å…¨å¢å¼º

#### 4.2.1 ç¨ç‡æ“ä½œé˜²æŠ¤

```solidity
// é˜²æ­¢ç¨ç‡è¿‡é«˜
function setTaxConfig(
    uint256 buyTax,
    uint256 sellTax,
    uint256 transferTax,
    uint256 liquidityTax,
    bool dynamicEnabled,
    uint256 maxDynamicRate
) external onlyOwner {
    require(buyTax <= MAX_TRANSACTION_TAX_RATE, "HZ: buy tax too high");
    require(sellTax <= MAX_TRANSACTION_TAX_RATE, "HZ: sell tax too high");
    require(transferTax <= MAX_TRANSACTION_TAX_RATE, "HZ: transfer tax too high");
    require(liquidityTax <= MAX_TRANSACTION_TAX_RATE, "HZ: liquidity tax too high");
    require(maxDynamicRate <= 500, "HZ: max dynamic rate too high"); // æœ€å¤§5å€
    
    // æ›´æ–°é…ç½®...
}
```

#### 4.2.2 AMMæ± è¯†åˆ«å®‰å…¨

```solidity
// é˜²æ­¢æ¶æ„åœ°å€ä¼ªè£…AMMæ± 
function setAMM(address pool, bool isPool) external onlyOwner {
    require(pool != address(0), "HZ: invalid pool address");
    require(pool != address(this), "HZ: cannot set self as AMM");
    
    // å¯ä»¥æ·»åŠ é¢å¤–çš„éªŒè¯é€»è¾‘ï¼Œæ¯”å¦‚æ£€æŸ¥æ˜¯å¦æ˜¯çœŸå®çš„Uniswapæ± 
    isAMM[pool] = isPool;
    emit AMMUpdated(pool, isPool);
}
```

---

## 5. ğŸ”§ æ–°å¢å®‰å…¨æœºåˆ¶

### 5.1 åˆ†å±‚IDç®¡ç†ç³»ç»Ÿ

#### 5.1.1 åŒå‘æ˜ å°„é˜²ç¯¡æ”¹

```solidity
struct IdManager {
    uint256 nextOnChainId;
    mapping(uint256 => uint256) offChainToOnChain;  // é“¾ä¸‹ID â†’ é“¾ä¸ŠID
    mapping(uint256 => uint256) onChainToOffChain;  // é“¾ä¸ŠID â†’ é“¾ä¸‹ID
    mapping(uint256 => bool) offChainIdExists;      // é“¾ä¸‹IDå­˜åœ¨æ€§
    mapping(bytes32 => bool) requestHashExists;     // è¯·æ±‚å“ˆå¸Œå­˜åœ¨æ€§
}

function _createIdMapping(uint256 offChainId, uint256 nonce) internal returns (uint256 onChainId) {
    // é˜²æ­¢é“¾ä¸‹IDé‡å¤
    require(!idManager.offChainIdExists[offChainId], "MiningPool: offchain ID already exists");
    
    // ç”Ÿæˆå”¯ä¸€è¯·æ±‚å“ˆå¸Œ
    bytes32 requestHash = keccak256(abi.encodePacked(
        msg.sender, 
        offChainId, 
        nonce, 
        block.timestamp
    ));
    require(!idManager.requestHashExists[requestHash], "MiningPool: duplicate request hash");
    
    // åˆ›å»ºåŒå‘æ˜ å°„
    onChainId = idManager.nextOnChainId++;
    idManager.offChainToOnChain[offChainId] = onChainId;
    idManager.onChainToOffChain[onChainId] = offChainId;
    idManager.offChainIdExists[offChainId] = true;
    idManager.requestHashExists[requestHash] = true;
    
    emit IdMappingCreated(onChainId, offChainId, requestHash);
}
```

#### 5.1.2 æ‰¹é‡éªŒè¯åŠŸèƒ½

```solidity
function validateOffChainIds(uint256[] calldata offChainIds) 
    external view returns (bool[] memory valid, uint256[] memory onChainIds) {
    
    valid = new bool[](offChainIds.length);
    onChainIds = new uint256[](offChainIds.length);
    
    for (uint256 i = 0; i < offChainIds.length; i++) {
        valid[i] = idManager.offChainIdExists[offChainIds[i]];
        if (valid[i]) {
            onChainIds[i] = idManager.offChainToOnChain[offChainIds[i]];
        }
    }
}
```

### 5.2 è¿‡æœŸè¯·æ±‚æ¸…ç†æœºåˆ¶

```solidity
function cleanupExpiredRequests(uint256[] calldata expiredIds) external {
    uint256 cleanedCount = 0;
    
    for (uint256 i = 0; i < expiredIds.length; i++) {
        WithdrawalRequest storage request = withdrawalRequests[expiredIds[i]];
        
        // åªæ¸…ç†è¿‡æœŸçš„å¾…å®¡æ‰¹è¯·æ±‚
        if (request.status == WithdrawalStatus.PENDING && 
            block.timestamp > request.timestamp + requestExpiryTime) {
            
            request.status = WithdrawalStatus.EXPIRED;
            cleanedCount++;
            
            emit RequestExpired(expiredIds[i], request.beneficiary);
        }
    }
    
    require(cleanedCount > 0, "MiningPool: no expired requests to clean");
    emit ExpiredRequestsCleaned(msg.sender, cleanedCount);
}
```

### 5.3 å®æ—¶ç»Ÿè®¡ç›‘æ§

```solidity
struct WithdrawalStatistics {
    uint256 totalWithdrawn;           // æ€»æå–ä»£å¸æ•°é‡
    uint256 totalMiningReleased;      // å·²é‡Šæ”¾æŒ–çŸ¿ä»£å¸æ€»æ•°
    uint256 smallWithdrawCount;       // å°é¢æç°æ¬¡æ•°
    uint256 mediumWithdrawCount;      // ä¸­é¢æç°æ¬¡æ•°
    uint256 largeWithdrawCount;       // å¤§é¢æç°æ¬¡æ•°
    uint256 totalRequestCount;        // æ€»è¯·æ±‚æ•°é‡
}

WithdrawalStatistics public stats;

function _updateStatistics(uint256 amount, ApprovalLevel level) internal {
    stats.totalWithdrawn += amount;
    stats.totalRequestCount++;
    
    if (level == ApprovalLevel.SMALL) {
        stats.smallWithdrawCount++;
    } else if (level == ApprovalLevel.MEDIUM) {
        stats.mediumWithdrawCount++;
    } else {
        stats.largeWithdrawCount++;
    }
}
```

---

## 6. æƒé™ç®¡ç†

### 6.1 è§’è‰²å®šä¹‰

```solidity
contract RoleManagement is AccessControl {
    // è§’è‰²å®šä¹‰
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
    bytes32 public constant BLACKLIST_MANAGER_ROLE = keccak256("BLACKLIST_MANAGER_ROLE");
    bytes32 public constant VESTING_MANAGER_ROLE = keccak256("VESTING_MANAGER_ROLE");
    
    // æƒé™çŸ©é˜µ
    struct Permission {
        bool canMint;
        bool canPause;
        bool canBlacklist;
        bool canManageVesting;
    }
    
    mapping(bytes32 => Permission) public rolePermissions;
    
    constructor() {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        
        // é…ç½®è§’è‰²æƒé™
        rolePermissions[MINTER_ROLE] = Permission(true, false, false, false);
        rolePermissions[PAUSER_ROLE] = Permission(false, true, false, false);
        rolePermissions[BLACKLIST_MANAGER_ROLE] = Permission(false, false, true, false);
        rolePermissions[VESTING_MANAGER_ROLE] = Permission(false, false, false, true);
    }
}
```

### 6.2 å¤šé‡ç­¾å

```solidity
contract MultiSigWallet {
    mapping(address => bool) public isOwner;
    uint256 public required;
    uint256 public ownerCount;
    
    struct Transaction {
        address to;
        uint256 value;
        bytes data;
        bool executed;
        uint256 confirmations;
    }
    
    mapping(uint256 => Transaction) public transactions;
    mapping(uint256 => mapping(address => bool)) public confirmations;
    
    modifier onlyOwner() {
        require(isOwner[msg.sender], "Not owner");
        _;
    }
    
    modifier notExecuted(uint256 transactionId) {
        require(!transactions[transactionId].executed, "Already executed");
        _;
    }
    
    function confirmTransaction(uint256 transactionId) 
        external 
        onlyOwner 
        notExecuted(transactionId) {
        
        confirmations[transactionId][msg.sender] = true;
        transactions[transactionId].confirmations++;
        
        if (transactions[transactionId].confirmations >= required) {
            executeTransaction(transactionId);
        }
    }
}
```

### 6.3 æ—¶é—´é”

```solidity
contract TimeLock {
    mapping(bytes32 => uint256) public queuedTransactions;
    uint256 public constant DELAY = 2 days;
    
    modifier onlyTimelock() {
        require(msg.sender == address(this), "Not timelock");
        _;
    }
    
    function queueTransaction(
        address target,
        uint256 value,
        string memory signature,
        bytes memory data,
        uint256 eta
    ) external onlyRole(ADMIN_ROLE) returns (bytes32) {
        require(eta >= block.timestamp + DELAY, "Insufficient delay");
        
        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));
        queuedTransactions[txHash] = eta;
        
        emit QueueTransaction(txHash, target, value, signature, data, eta);
        return txHash;
    }
    
    function executeTransaction(
        address target,
        uint256 value,
        string memory signature,
        bytes memory data,
        uint256 eta
    ) external payable onlyRole(ADMIN_ROLE) returns (bytes memory) {
        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));
        
        require(queuedTransactions[txHash] != 0, "Not queued");
        require(block.timestamp >= eta, "Too early");
        require(block.timestamp <= eta + GRACE_PERIOD, "Expired");
        
        queuedTransactions[txHash] = 0;
        
        // æ‰§è¡Œäº¤æ˜“
        bytes memory callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);
        (bool success, bytes memory returnData) = target.call{value: value}(callData);
        require(success, "Execution failed");
        
        emit ExecuteTransaction(txHash, target, value, signature, data, eta);
        return returnData;
    }
}
```

---

## 7. åº”æ€¥å“åº”

### 7.1 åº”æ€¥æœºåˆ¶

#### 7.1.1 ç´§æ€¥æš‚åœ

```solidity
contract EmergencyPause is Pausable {
    address public emergencyAdmin;
    uint256 public pauseStartTime;
    uint256 public constant MAX_PAUSE_DURATION = 7 days;
    
    event EmergencyPause(address indexed admin, string reason);
    event EmergencyUnpause(address indexed admin);
    
    modifier onlyEmergencyAdmin() {
        require(msg.sender == emergencyAdmin, "Not emergency admin");
        _;
    }
    
    function emergencyPause(string memory reason) 
        external 
        onlyEmergencyAdmin {
        _pause();
        pauseStartTime = block.timestamp;
        emit EmergencyPause(msg.sender, reason);
    }
    
    function emergencyUnpause() external onlyEmergencyAdmin {
        require(paused(), "Not paused");
        _unpause();
        emit EmergencyUnpause(msg.sender);
    }
    
    // è‡ªåŠ¨è§£é™¤æš‚åœ (é˜²æ­¢æ°¸ä¹…æš‚åœ)
    function autoUnpause() external {
        require(paused(), "Not paused");
        require(
            block.timestamp >= pauseStartTime + MAX_PAUSE_DURATION,
            "Pause period not expired"
        );
        _unpause();
    }
}
```

#### 7.1.2 èµ„é‡‘å†»ç»“

```solidity
contract FundFreeze {
    mapping(address => bool) public frozenAccounts;
    mapping(address => uint256) public frozenUntil;
    
    event AccountFrozen(address indexed account, uint256 until, string reason);
    event AccountUnfrozen(address indexed account);
    
    modifier notFrozen(address account) {
        require(!frozenAccounts[account], "Account frozen");
        require(frozenUntil[account] < block.timestamp, "Account temporarily frozen");
        _;
    }
    
    function freezeAccount(
        address account, 
        uint256 duration, 
        string memory reason
    ) external onlyRole(FREEZE_ROLE) {
        frozenAccounts[account] = true;
        frozenUntil[account] = block.timestamp + duration;
        emit AccountFrozen(account, frozenUntil[account], reason);
    }
    
    function unfreezeAccount(address account) 
        external 
        onlyRole(FREEZE_ROLE) {
        frozenAccounts[account] = false;
        frozenUntil[account] = 0;
        emit AccountUnfrozen(account);
    }
}
```

### 7.2 äº‹ä»¶å“åº”æµç¨‹

```
1. å¨èƒæ£€æµ‹
   â†“
2. é£é™©è¯„ä¼°
   â†“
3. åº”æ€¥å†³ç­–
   â†“
4. æ‰§è¡Œæªæ–½
   â†“
5. å½±å“è¯„ä¼°
   â†“
6. æ¢å¤è®¡åˆ’
   â†“
7. äº‹ååˆ†æ
```

#### 7.2.1 å¨èƒæ£€æµ‹

```solidity
contract ThreatDetection {
    struct AlertConfig {
        uint256 largeTransferThreshold;
        uint256 frequentTransferLimit;
        uint256 timeWindow;
    }
    
    AlertConfig public alertConfig;
    mapping(address => uint256) public transferCount;
    mapping(address => uint256) public lastTransferTime;
    
    event LargeTransferAlert(address indexed from, address indexed to, uint256 amount);
    event FrequentTransferAlert(address indexed account, uint256 count);
    
    function _checkTransferAlerts(
        address from, 
        address to, 
        uint256 amount
    ) internal {
        // å¤§é¢è½¬è´¦å‘Šè­¦
        if (amount >= alertConfig.largeTransferThreshold) {
            emit LargeTransferAlert(from, to, amount);
        }
        
        // é¢‘ç¹è½¬è´¦å‘Šè­¦
        if (block.timestamp - lastTransferTime[from] < alertConfig.timeWindow) {
            transferCount[from]++;
            if (transferCount[from] >= alertConfig.frequentTransferLimit) {
                emit FrequentTransferAlert(from, transferCount[from]);
            }
        } else {
            transferCount[from] = 1;
        }
        
        lastTransferTime[from] = block.timestamp;
    }
}
```

### 7.3 æ¢å¤æœºåˆ¶

```solidity
contract DisasterRecovery {
    address public backupAdmin;
    uint256 public emergencyRecoveryDelay = 30 days;
    mapping(bytes32 => uint256) public recoveryProposals;
    
    struct RecoveryProposal {
        address newOwner;
        uint256 proposalTime;
        bool executed;
        string reason;
    }
    
    mapping(bytes32 => RecoveryProposal) public proposals;
    
    function proposeRecovery(
        address newOwner, 
        string memory reason
    ) external {
        require(msg.sender == backupAdmin, "Not backup admin");
        
        bytes32 proposalId = keccak256(abi.encodePacked(newOwner, block.timestamp));
        
        proposals[proposalId] = RecoveryProposal({
            newOwner: newOwner,
            proposalTime: block.timestamp,
            executed: false,
            reason: reason
        });
        
        emit RecoveryProposed(proposalId, newOwner, reason);
    }
    
    function executeRecovery(bytes32 proposalId) external {
        RecoveryProposal storage proposal = proposals[proposalId];
        
        require(!proposal.executed, "Already executed");
        require(
            block.timestamp >= proposal.proposalTime + emergencyRecoveryDelay,
            "Delay not met"
        );
        
        proposal.executed = true;
        _transferOwnership(proposal.newOwner);
        
        emit RecoveryExecuted(proposalId, proposal.newOwner);
    }
}
```

---

## 8. å®¡è®¡å’Œç›‘æ§

### 8.1 ä»£ç å®¡è®¡

#### 8.1.1 é™æ€åˆ†æ

```bash
# ä½¿ç”¨ Slither è¿›è¡Œé™æ€åˆ†æ
slither contracts/

# ä½¿ç”¨ MythX è¿›è¡Œå®‰å…¨åˆ†æ
mythx analyze contracts/HZToken.sol

# ä½¿ç”¨ Echidna è¿›è¡Œæ¨¡ç³Šæµ‹è¯•
echidna-test contracts/HZToken.sol --contract HZToken
```

#### 8.1.2 æµ‹è¯•è¦†ç›–ç‡

```javascript
// æµ‹è¯•ç”¨ä¾‹ç¤ºä¾‹
describe("Security Tests", function() {
  it("should prevent reentrancy attacks", async function() {
    const maliciousContract = await MaliciousContract.deploy();
    
    await expect(
      maliciousContract.attack(hzToken.address)
    ).to.be.revertedWith("ReentrancyGuard: reentrant call");
  });
  
  it("should enforce access controls", async function() {
    await expect(
      hzToken.connect(user).mint(user.address, 1000)
    ).to.be.revertedWith("AccessControl: account");
  });
  
  it("should handle integer overflow", async function() {
    const maxUint256 = ethers.constants.MaxUint256;
    
    await expect(
      hzToken.transfer(user.address, maxUint256)
    ).to.be.reverted; // Solidity 0.8+ è‡ªåŠ¨æ£€æŸ¥
  });
});
```

### 8.2 å®æ—¶ç›‘æ§

#### 8.2.1 é“¾ä¸Šç›‘æ§

```javascript
// ç›‘æ§è„šæœ¬
const monitorContract = async () => {
  const hzToken = new ethers.Contract(TOKEN_ADDRESS, ABI, provider);
  
  // ç›‘å¬å¤§é¢è½¬è´¦
  hzToken.on("Transfer", (from, to, amount, event) => {
    const amountEth = ethers.utils.formatEther(amount);
    
    if (parseFloat(amountEth) > 1000000) { // 100ä¸‡ä»£å¸
      console.log(`ğŸš¨ å¤§é¢è½¬è´¦å‘Šè­¦: ${from} -> ${to}, é‡‘é¢: ${amountEth} HZ`);
      sendAlert({
        type: "LARGE_TRANSFER",
        from, to, amount: amountEth,
        txHash: event.transactionHash
      });
    }
  });
  
  // ç›‘å¬æƒé™å˜æ›´
  hzToken.on("RoleGranted", (role, account, sender, event) => {
    console.log(`ğŸ” æƒé™æˆäºˆ: è§’è‰²=${role}, è´¦æˆ·=${account}, æˆæƒäºº=${sender}`);
    sendAlert({
      type: "ROLE_GRANTED",
      role, account, sender,
      txHash: event.transactionHash
    });
  });
};
```

#### 8.2.2 å¼‚å¸¸æ£€æµ‹

```javascript
const detectAnomalies = async () => {
  const currentBlock = await provider.getBlockNumber();
  const fromBlock = currentBlock - 1000; // æœ€è¿‘1000ä¸ªåŒºå—
  
  // è·å–è½¬è´¦äº‹ä»¶
  const transfers = await hzToken.queryFilter(
    hzToken.filters.Transfer(),
    fromBlock,
    currentBlock
  );
  
  // åˆ†æè½¬è´¦æ¨¡å¼
  const transferAnalysis = analyzeTransfers(transfers);
  
  if (transferAnalysis.suspiciousPatterns.length > 0) {
    console.log("ğŸš¨ æ£€æµ‹åˆ°å¯ç–‘è½¬è´¦æ¨¡å¼:");
    transferAnalysis.suspiciousPatterns.forEach(pattern => {
      console.log(`- ${pattern.description}`);
    });
  }
};

function analyzeTransfers(transfers) {
  const analysis = {
    totalTransfers: transfers.length,
    uniqueAddresses: new Set(),
    largeTransfers: [],
    frequentTransfers: {},
    suspiciousPatterns: []
  };
  
  transfers.forEach(transfer => {
    const { from, to, value } = transfer.args;
    
    analysis.uniqueAddresses.add(from);
    analysis.uniqueAddresses.add(to);
    
    // æ£€æµ‹å¤§é¢è½¬è´¦
    if (value.gt(ethers.utils.parseEther("100000"))) {
      analysis.largeTransfers.push(transfer);
    }
    
    // æ£€æµ‹é¢‘ç¹è½¬è´¦
    const key = `${from}-${to}`;
    analysis.frequentTransfers[key] = (analysis.frequentTransfers[key] || 0) + 1;
    
    if (analysis.frequentTransfers[key] > 10) {
      analysis.suspiciousPatterns.push({
        type: "FREQUENT_TRANSFERS",
        description: `${from} å‘ ${to} è½¬è´¦ ${analysis.frequentTransfers[key]} æ¬¡`
      });
    }
  });
  
  return analysis;
}
```

### 8.3 å®‰å…¨ä»ªè¡¨æ¿

```javascript
// å®‰å…¨æŒ‡æ ‡æ”¶é›†
const collectSecurityMetrics = async () => {
  const metrics = {
    timestamp: Date.now(),
    
    // åˆçº¦çŠ¶æ€
    contractStatus: {
      isPaused: await hzToken.paused(),
      totalSupply: await hzToken.totalSupply(),
      blacklistedAccounts: await getBlacklistedCount(),
    },
    
    // æƒé™çŠ¶æ€
    permissions: {
      adminCount: await hzToken.getRoleMemberCount(DEFAULT_ADMIN_ROLE),
      minterCount: await hzToken.getRoleMemberCount(MINTER_ROLE),
      pauserCount: await hzToken.getRoleMemberCount(PAUSER_ROLE),
    },
    
    // äº¤æ˜“ç»Ÿè®¡
    transactions: {
      last24h: await getTransactionCount(24),
      averageGasUsed: await getAverageGasUsed(),
      failedTransactions: await getFailedTransactionCount(),
    },
    
    // å®‰å…¨äº‹ä»¶
    securityEvents: {
      alerts: await getRecentAlerts(),
      suspiciousActivities: await getSuspiciousActivities(),
    }
  };
  
  return metrics;
};
```

---

## å®‰å…¨æœ€ä½³å®è·µ

### å¼€å‘é˜¶æ®µ
1. **å®‰å…¨ç¼–ç **: éµå¾ª Solidity å®‰å…¨æœ€ä½³å®è·µ
2. **ä»£ç å®¡æŸ¥**: å¤šäººå®¡æŸ¥å…³é”®ä»£ç 
3. **å•å…ƒæµ‹è¯•**: 100% æµ‹è¯•è¦†ç›–ç‡
4. **é™æ€åˆ†æ**: ä½¿ç”¨è‡ªåŠ¨åŒ–å®‰å…¨å·¥å…·
5. **æ¨¡ç³Šæµ‹è¯•**: è¾¹ç•Œæ¡ä»¶å’Œå¼‚å¸¸æƒ…å†µæµ‹è¯•

### éƒ¨ç½²é˜¶æ®µ
1. **æµ‹è¯•ç½‘éªŒè¯**: å®Œæ•´çš„æµ‹è¯•ç½‘éƒ¨ç½²å’Œæµ‹è¯•
2. **ä»£ç å®¡è®¡**: ç¬¬ä¸‰æ–¹ä¸“ä¸šå®‰å…¨å®¡è®¡
3. **å¤šç­¾éƒ¨ç½²**: ä½¿ç”¨å¤šé‡ç­¾åé’±åŒ…éƒ¨ç½²
4. **æƒé™æœ€å°åŒ–**: æœ€å°å¿…è¦æƒé™åŸåˆ™
5. **ç›‘æ§å‡†å¤‡**: éƒ¨ç½²å‰å‡†å¤‡ç›‘æ§ç³»ç»Ÿ

### è¿è¥é˜¶æ®µ
1. **æŒç»­ç›‘æ§**: 24/7 å®‰å…¨ç›‘æ§
2. **å®šæœŸå®¡æŸ¥**: å®šæœŸå®‰å…¨å®¡æŸ¥å’Œæ›´æ–°
3. **åº”æ€¥æ¼”ç»ƒ**: å®šæœŸåº”æ€¥å“åº”æ¼”ç»ƒ
4. **ç¤¾åŒºæŠ¥å‘Š**: å»ºç«‹æ¼æ´æŠ¥å‘Šæœºåˆ¶
5. **ä¿é™©è¦†ç›–**: è€ƒè™‘æ™ºèƒ½åˆçº¦ä¿é™©

---

**å®‰å…¨å·¥å…·æ¨è**:
- [Slither](https://github.com/crytic/slither) - é™æ€åˆ†æ
- [MythX](https://mythx.io/) - å®‰å…¨åˆ†æå¹³å°
- [Echidna](https://github.com/crytic/echidna) - æ¨¡ç³Šæµ‹è¯•
- [Manticore](https://github.com/trailofbits/manticore) - ç¬¦å·æ‰§è¡Œ
- [Tenderly](https://tenderly.co/) - ç›‘æ§å’Œè°ƒè¯•

---

*æ–‡æ¡£ç‰ˆæœ¬: v2.1*  
*æœ€åæ›´æ–°: 2025å¹´8æœˆ4æ—¥*
*åŒ…å«é‡å¤§å®‰å…¨æ¼æ´ä¿®å¤å’Œæ–°å¢å®‰å…¨æœºåˆ¶*